'CR1000 or CR6 Series Datalogger
'Program Authors
'Michael R. Simpson
'HydroInterface
'Trevor Violette and Jim DeRose, USGS
'Program Version Date
Const ProgramVersionDate = 20190409
'Last Modified by: Trevor Violette
'UNIVERSAL PROGRAM -- May need some trimming!!! NOTE! THIS PROGRAM WILL NOT COMPILE ON CR1000 OS 28 or EARLIER!

'-----------------IMPORTANT IMPORTANT-----------------------------------------------
'BEFORE COMPILING:
' 1 SET DLD DATALOGGER TYPE IN TOOLS MENU FOR THE TARGET DATALOGGER
' 2 CHOOSE COSTOMIZE CONSTANTS IN TOOLS MENU, SELECT PROPER CONSTANTS FOR THE TARGET STATION
' 3 CHOOSE CONDITIONAL COMPILE AND SAVE IN THE COMPILE MENU. RENAME THE FILE WITH STATION ID AND DATE IN FILENAME USING CR6 or CR1 file extension
' 4 LOAD THE SAVED FILE INTO THE STATION DATALOGGER OR YOU CAN LOAD THE ORIGINAL DLD FILE IF SPACE PERMITS.
' 5 DO NOT USE A MAX232 ADAPTER ON THE CSI/0 (ComME) port

'Note: Pos Flow angle can only be used on 4 beam uplookers using EARTH coordinate transformation.
'its use in any other configuration is disabled after the first ensemble.
'If using BEAM coordinate transformation on a Channel Master, You MUST obtain an external HEADING determination as there is NO internal compass!
'If using a Bi-directional rating (Ebb/Flood) with different bins for each direction you must be using a channel master with insturment coordinates, you must set Birating to true in the startup parameters.
'You also must set StartBin, EndBin, StartEbbBin, EndEbbBin, StartFldBin, and EbbFldBin to appropriate values (ebb = pos) (Fld = neg)  Startbin and Endbin should include all the bins used
'for both ebb and flood calculations. You also have to set BiRatTran to the velocity That you wish calculations to switch from Ebb bins to Flood Bins. The program will make sure you are using
'a Channel Master with instrument coords before applying the Ebb/Flood bin differences. If you are using any other VM or coord system, it will use the standard method to calculate iVel.
'You can include V2 (Y velocity) in the IndexVel calculation if you wish to use it. Just make sure UseV2 is True.

'_______________________________PROGRAM UPDATES_________________________________________
'20090211 - MRS and PRS averaged beams for each bin added to coorelation and RSSI decoders
'20090211 - PRS cleaned up program slightly
'20090212 - PRS  WHvolts added to variable leader decoder; defined a prelimary output table
'20090213 - JBD added bells\whistles and data tables, many minor changes to subroutines
'20090213 - PRS added Evel and Nvel to Flow Data Keypad Menu; flow direction included in 15 min output table; converted mm/sec to ft/sec// changed to V1 and V2 20100808
'20090219 - MRS and PRS added subroutine CalcLastGoodBin to calculate last good bin based on good RSSI and Coorelation
'20090220 - PRS added some variables to keypad
'20090319 - PRS added MaxRSSIBin to data out for troubleshooting purposes, decreased RSSI spike down to 5 counts
'20090320 - JBD moved calls to keypad and stage ahead of call to uplooker
'20090331 - PRS decreased RSSI spike down to 4 counts for the 600kHz system
'20090410 - PRS modified subrountine CalcLastGoodBin to allow the user to set the RSSI and Corr filter numbers
'20090422 - PRS modified subroutine CalcLastGoodBin to startbin filtering at 2nd bin, assume 1st bin is good
'20090428 - PRS set correlation threshold as 120 per RDI FSA022
'20090507 - PRS modified subroutine CalcLastGoodBin to use standard deviation of correlation values to filter good bins
'20090605 - PRS added subroutines to filter bad ensembles and monitor the bad ensembles
'20090606 - PRS modified subroutines CalcLastGoodBin to include different filtering cases
'20090609 - PRS modified subroutines CalcLastGoodBin and EnsFilter
'20090610 - PRS Added Subroutine to get CTD Data, plus some modification to stage routine //MRS removed CTD routine -- added YSI
'20090612 - PRS Modified GetCTD subroutine to convert units
'20090825 - PRS Added function to zero pressure sensor, put the counter resets in the main program, correlation and RSSI data for each beam and bin will be output
'           switched from 5 sec scan to 10 sec scan //MRS removed the function to zero pressure sensor -- use offsets
'20091027 - PRS Corrected GetPSPress Subroutine to Zero pressure sensor correctly; added SiteInfo Table to generate SiteParameters when called by Tech
'20091110 - PRS corrected the program to listen for ADCP data instead of sending a CS command, and added Station specific principle directions of flow
'20091117 - PRS,MRS Added code to check for hex 7F7F at start of ensenble and to adjust array to beginning.  Also added code to calculate checksum of
'           incoming data and discard data if calc checksum and ensemble checksum (sent by ADCP) do not agree!
'20091123 - PRS revised the calc last good bin filter to filter out bad bins based on three thresholds
'20091202 - PRS revised Last Good Bin Filter, other minor changes
'20091211 - PRS made some slight changes in LastGoodBinFilter, and added LastGoodBinCheck
'20091216 - PRS modified the way the ADCP data comes in to ensure if there is a transmission error that the program doesnt lock up
'20100610 - MRS modified and cleaned up code to allow communication with Channel Master
'20100623 - MRS Changed true to yes and false to no for JBD's convention
'20100705 - MRS Added YSI subroutine and checking, deleted CTD routine
'20100720 - MRS Added VMstage decode subroutine to decode vertical beam and VM pressure data
'20100724 - MRS Added Loop in Main Decode routine to Check Profile data IDs and apply the correct Offset
'20100806 - MRS Removed Workhorse code (E and N velocities and speed and direction calculations)
'20100807 - MRS Added Filter routines for turbidity and velocity
'20100811 - MRS Added Ablility to FTP QA/QC File at fixed time intervals
'20100818 - MRS Cleaned up code and added comments where needed
'20100907 - JBD Further cleaned\standardized code where needed
'20100916 - MRS moved some code in scan loop to subroutines
'20100920 - MRS fleshed out QA/QC data table
'20100922 - MRS finished v4 test program: added ADCP realtime clock decode and restart attempts variable
'20101007 - MRS Made changes to the cdma stuff -- Added Deep Water Channel defaults to startup subroutine
'20101014 - MRS Added Code to output RSSI average over selected bins -- Moved Allbin RSSI data to new backscatter table --
'20101122 - MRS Worked on Velocity and Stage Spike filters to make them independent of Scan Rate
'20101123 - MRS Replace IFTime Statements with MOD calculations to allow for skipped scans
'20101124 - MRS added code to include all bins in output, but only average user selected bins for iVel
'20101202 - MRS added default flow sign to prevent output of zero velocities
'20101204 - JBD Moved ProgramVersion to top of program and changed variable and added to QAQCInfo datatable
'20101204 - JBD Dimmed out many Public variables (Mike make sure I didn't Dim out any you want to see?)
'20101204 - JBD modified CDMA cycling subroutine (with LoopInterval) to work properly
'20101204 - JBD removed SysInfo datatable and modified QAQCInfo datatable (calls at midnight, Tech visit, no YsiErrCount or BadQcount = 200)
'20101204 - JBD Mike, need to make sure UsrDriveSize will still work with available storage?
'20101204 - JBD put default values for all station parameters in Startup (many are just set to zero. Change before sending to site)
'20101204 - JBD removed the SgtRef Variable (was not ever used)
'20101205 - MRS inserted SubScan statement to allow 60 sec main scan interval while scanning VM for data every 15 seconds
'20101205 - MRS Created DataTable Event for events that cannot wait for 2400 hours - BadQ or BadYSI, tech visit, cdma cycle, and low battery volts.
'20101205 - MRS Created flags so that Event table is only transmitted once every 24 hours
'20101205 - MRS Modified QAQCinfo table so that it is called every scan (for avg, max and min), but only stores and transmits at 5 min past midnight (need to test)
'20101206 - MRS Added small delay after table called to allow time for data storage
'20101206 - JBD removed BadStgCount from the Event table (covered by BadQCount)
'20101207 - MRS added code to assure that only 1 record is stored in QAQCinfo, and added flag for CDMA Clycle to only send warning once per day
'20101208 - MRS Moved FTP code to SlowSequence so ftp delay will not delay main scan
'20101208 - MRS Moved call to CDMA check inside of 15 second subscan
'20101209 - MRS Reset counters at 5 minutes after midnight so that QAQC file has full counter values
'20101209 - MRS Added code suggested by JBD to the YSI data sub menu
'20101210 - JBD Changed the Catastrophy and USR filename to Event
'20101210 - JBD Added some flow\sensor data to the Event table (so we can use as electronic site visit)
'20101210 - JBD Added code to automatically calculate the depth of the YsiSonde based upon initial depth reading
'20101210 - MRS Added 200ms after last call to QAQC to allow time for file storage.
'20101213 - MRS Corrected errors due to file name change from CAT to Event
'20101213 - MRS Changed SW12 statements to allow for normally closed relays
'20110123 - MRS Changed code to allow for both normally open or normally closed CDMA relays -- Defaults to normally closed
'20110615 - JBD Changed the FTP startup defaults, and fixed realtime calculation of Ysi Sonde Depth.
'20110615 - JBD restructured startup default table, and Keypad menu to make more user friendly.
'20110624 - MRS Created debugging version to investigate depth problem
'20110717 - MRS Added decode blocks for vertical commands and amplitude
'20110801 - MRS Added Structure to send commands to ADCP
'20110816 - MRS Deleted amplitude decode subroutine
'20110830 - MRS Added Generic startup block, Added trigger variable for stage 2, Cleaned up code
'20110913 - MRS Added code for banner and CSCmd In WakeVM block
'20110915 - MRS Added code for above and below rating indicators
'20111029 - MRS Added bug fix for random data in StagePrime or stageSecnd if bad value
'20111109 - JBD and MRS removed spike filters, cleaned up, added Median filter to output table
'20111116 - JBD added LowRatVel and HighRatVel and YsiOffset to startup parameters..
'20111121 - JBD added a "SiteVisit" data table, and more choices to site visit reason in keypad menu
'20111121 - JBD standardized CM (Chanel Master) to VM (Velocity Meter) so code can be more easily adapted to other programs
'20111215 - JBD and MRS dimmed out a few more public variables..
'20111229 - JBD cleaned up unnecessary comments, re-arranged routines etc.
'20120110 - JBD added code to keep VM power relay from switching off during site visits.
'20120119 - JBD added a 1min datatable to collect calibration data
'20120120 - JBD added RssiSwath and bin correlation to backskatter data table
'20120130 - MRS added new table "BeamCheck" to record 24hrs of raw RSSI and Corr data on 1st of Month or if user flag set
'20120209 - JBD moved some startup variables out of the Paremeters section, and shortened some keypad menu names
'20120209 - MRS Corrected program big wherein user beamcheck data collection was terminated too early
'20120214 - JBD added stagePrime to the beam check data table
'20120425 - MRS added baudrate choice 9600 or 38400 -- defaults to 38400
'20120430 - MRS Modifed for vemco router use
'20121114 - JBD put in code to wake up CM once per hour to fix sensor glitch (line ~2138)
'20130221 - JBD added code to CDMACheck that when turned on runs CDMA 10mins per hour
'20130625 - JBD changed to float tape code to code for a second pressure sensor
'20130709 - JBD added code to toggle off discharge calculations
'20131104 - JBD slightly modified the pressure sensor subroutines (Bug in PSpress2) and cleaned up some stage related comments
'20131104 - JBD changed the main program scan buffer from 3 to 5
'20131113 - JBD added VMHeading to relevant datatables (for WH HADCPs with compasses)
'20131123 - MRS Added Coordinate system decoding variables
'20131123 - MRS Changed Xvel Yvel Zvel and Evel to V1, V2, V3, and V4 for universal decoding
'20131123 - MRS Fixed bug in ensemble decoding because of Com framing error
'20131123 - MRS Added optional principal flow direction calculation for Earth Coordinate systems
'20131123 - MRS Added Flag to allow recording all beam velocities for use in Radial beam velocity applications and Uplooker applications
'20140131 - JBD modified startup teble to turn on beam check automatically at startup
'20140131 - JBD changed all Cond, Vel and Q variables type in the data out tables from FP2 to IEEE4
'20140131 - JBD consolidate some variables table into the QAQC data table
'20140205 - DWH corrected multiplyer for 3 and 4 byte numbers
'20140218 - MRS corrected code in velocity decoder -- added disable array to use in avg and median reps
'20140218 - MRS corrected code for High and Low measurements
'20140301 - MRS Added code to decode WH pressure sensor
'20140530 - MRS Added code for DO %Saturation
'20140607 - MRS Added code for Stage from YSI
'20140707 - MRS Added code for pitch and roll in beamcheck datatable
'20140716 - MRS Added code to allow beamcheck and calibration data to be collected for 24 hours
'20140723 - MRS Corrected error for YSI stage calc.
'20140923 - MRS Added YSI variables ORP,BGA,FDOM,Ammonium,Nitrate, and Chloride
'20141008 - TAV Added code for stage3 in order to test and compare EXO sonde stage to pressure sensors
'20141204 - JBD Removed old code\comments and fixed minor bug in keypad menu,
'20141204 - JBD wrote code so YSI Locations cant be zero and cause "variable out of bounds error".
'20141208 - TAV changed "Trans" variable to a String in order to revert back to "NAN" in case of incidental changes
'20141216 - TAV testing to get rid of "LocStg" and "YsiStg" because the new EXOs have a pressure sensor, should be no need for these anymore
'               May look at keeping them to keep standardized program that'll work with 6600 or EXO, but turn them off when not needed.
'20150107 - TAV added code to check on the amount of memory left on WH recorder at 00:15 each day. Needed to be aware as WH won't
'               resume deployment if there's a power surge, etc. and there's no memory left.
'20150108 - TAV added a StgRef that will populate in the SiteVisit datatable so we know what the reference (staff or wire weight) at time of visit
'20150114 - TAV,DEA,AAD added variables to allow for an indicator if someone had a visual reference on the stage. Created counter for reference
'           to see how long ago the most recent visual refence on stage
'20150128 - TAV fixed bug in the bad stage flags, added "VisRefOK" to SiteVisit table to more easily see when someone got a reference
'20150205 - MRS Added Code for Bi-Directional rating (different bins depending on flow direction) BI-RATINGS CAN ONLY BE USE WITH CHANNEL MASTERS SET IN INSTRUMENT COODINATES
'20150211 - TAV added "WQVisit", "DiveVisit", and "DaysSince..." counters measurements, WQ, and Dive Visits in order to display values on RTMC
'               to more easily see when service is due at each station.
'20150213 - TAV added "FullVisit" and date variables for WQ, StgRefs, and Dives to more easily see when maintenance was accomplished.
'20150219 - TAV added code to reset "HighMeas" and "LowMeas" to "False" if someone changes the high or low RatVels
'20150309 - TAV added code to automatically get pressure sensor and ADCP serial numbers as well as flags to indicate when a new instrument has been installed
'20150322 - MRS added code to decode the ADCP sn from the LongArray so wakeup and PS0 not needed
'20150406 - TAV added code to send specific flow data to a second datalogger (in this case Sac Waste Water). And send all data tables to a second datalogger in order to test satellite communications.
'20150513 - MRS added panel temperature to serial data out for SRWTP
'20150514 - MRS deleted serial code and added SDI-12 sensor code to output flow data to SRWTP slave data logger.
'20150921 - TAV Added SiteID to VelData Table. Added YSI data to 1min table, created trigger to turn on YSI data. Edited Stage processes. Now uses "StagePrime" to calculate discharge (as before), but instead of "StageSecnd"
'               there are "UpbeamStg", "VMPressStg", "PS1Stg, "PS2Stg", and "YsiStg" and the corresponding "TrueStg" and "Offset" for each. This will keep data in USGS database more organized.
'               Added VMUpbeam and VMTemp to Beamcheck data for Suspended Sediment Concentration studies
'20151013 - MRS Corrected YSI error bug where the sub bypassed the error even if ysi was not sending data.
'20151015 - MRS Beamcheck now recording every 15 mins the time (for sediment data)
'20151116 - MRS Added Code to restart EXO (via the CDMA relay) if ysi data is not present for an hour
'20151118 - TAV Lots of commenting to make program easier to understand. Deleted "StageSecnd" and Stage3" and associated variables. Left the subroutine (commented out)
'               for reference. Changed "OSVersion" to "OSVers". OS28 and higher have "OSVersion" as a constant, somewhere.
'20151203 - TAV Fixed a stage bug. Added "StageSecnd" back in for the sole purpose of getting the differences between stage values (to see if there's drift). Added a TempDiff variable for comparison of YSI and VM Temp.
'               Now the user will select the instrument used to calculate Q (with "SelStgUsed") and the instrument to compare to (with "SelStg2"). At most stations it should be PS1 and PS2. Still need to do some more clean up.
'               A couple edits to the WQ parameters made, added a second FDOM (one is FdomRFU, the other FdomQSU), YsiDO is now "YsiDOmgL". Fixed Keypad menu as well.
'20151228 - TAV Finished up some thorough cleanup. Dimmed a lot of Variables. MRS will dim others. Eliminated "Startup" datatable as it's never been used. Moved BaudRate and VemcoRTR into the scan so user can change on the fly
'               Deleted PowerSwitch as all boards (minus a few Args) have relays now. Deleted "SendSatData" as this was just for testing purposes. Fixed "TrueStage" bug, user shouldn't have issues with the values not "taking" anymore.
'20160128 - MRS Modified the lastgoodbin routine to correctly identify changes in correllation magnitude as well as RSSI.  If profile range exceedes endbin, it no longer gives lastgoodbin as zero.
'               Also changed CorrThreshold to 15 vs 8 to allow for latest program modifications.  Also make sure to set endbin to last valid velocity bin if not lastgoodbin
'20160201 - TAV Added "IsSubmersed" variable to account for situations when we may use a CampbellSci submersible enclosure. If IsSubmersed = True Then use SW12 port to power and cycle ADCP. (No CDMA present)
'20160425 - TAV added code to allow the PT3 command to be parsed out in order to return noise floor for RDI instruments. Had to increase the "Warning" string as well as "SerialIn" command to 2000 to allow for adequate space.
'20160426 - TAV added "NoiseFloor" datatable and a few parameters to the BeamCheck datatable. Noise floor table will be written ONLY with "PT3" command is issued. PT3 command will be automatically once a day per the user's choice, and can be done manually
'20160427 - JBD added Subroutine to obtain external battery voltage from sources larger than 12 volts (36-48 volts)
'20160505 - TAV made a "SiteVisit" record be written when the PT3 command is issued, added YsiWiperPos to know the position of the wiper of the sonde. Useful for WQ processing.
'20160509 - TAV adjusted data types in the QAQC Table for "rVel" and "rStg" from FP2 to IEEE4.
'20160607 - TAV changed all values pertaining to discharge in data tables FROM "Median" to "Average"
'20160627 - JBD added max\min pannel temp to QAQC datatable
'20160629 - TAV dimmed "SelStgUsed" variable so techs CANNOT change primary stage on the fly. They would need to send new program to do so.
'20160711 - TAV finished YsiWiperPos code to alarm techs when the central wiper is outside the housing. Still needs testing! (But won't affect measurements)
'20160721 - TAV Created ConstTable to allow use of this program on either CR1000 or CR6 datalogger. NEED TO CLEAN UP PROGRAM. LOTS OF UNUSED VARIABLES.
'20160823 - MRS\JBD modified the program (hopefully) to work with the VADCP
'20161011 - TAV fixed a couple comport bugs (labelling) for CR6s.
'20161020 - TAV fixed the WakeUpVM to work appropriately with VADCP (needs a "CSTOP" command in order to actually reset instrument". General cleanup, deleted a bunch of unused variables.
'20170403 - TAV added "CardOut" instruction to the SiteVisit table so we would have backups of SiteVisit files.
'20171001 - MRS Program re-designed to Use conditional and custom compile statements and to include Spike detector, EXO serial and EXO burst.
'20180320 - TAV Changed "SiteNum" variable to variable type "String *16" to accomodate short term stations that have long station numbers. Deleted "DiveVisit" stuff. Not really useful anymore.
'20180321 - TAV added a lot of timers around the subroutines for debugging purposes only. Stored every minute in table called "Debugger". Once we're comfortable, we can delete those timers and only keep a couple (ScanStart, ScanEnd, BeforeBurst, AfterBurst, etc.)
'20180323 - TAV Modified the "StoreAllToCard" subroutine to exit the routine if something malfunctioned with the card. Adjusted Data Table sizes to accomodate the "StoreAllToCard" file being written
'               To the card. Current card allocations are: DataOut, Burst, AQ, VelData, BeamCheck: 17280 records (180 days), QAQC and NoiseFloor: 180 records (180 days, unless user activates the NoiseFloor manually)
'               and the SiteVisit table to accomodate 50 records. This allows for ~1.94GB on a 2GB card to be available to the "StoreAllToCard" function.
'               Added ConditionalCompile statements around all WQ variables. If there is no sonde, there's no reason to have the variables populate in the Public table.
'               Created a couple Customize Constants values: "Debugging", "ShowAllVel", and "ShowRawWQ". Allows user to choose whether they want variables associated with those things to be Public or Dim.
'20180329 - MRS Fixed bug causing array out of bounds error if ADCP setup for more than 27 bins. Replaced hard coded 27 with maxbins constant
'20180402 - TAV Fixed bug causing Aquarius table not to write if the logger expected WQ data but the WQ sonde was dead. Added a variable "RecAQFlag". If WQDead AND within 15 sec of 15min mark then RecAQFlag = True
'               Otherwise, resort to normal operation of recording flag with WQ data
'20180405 - TAV Built more timers and counters to narrow down bug causing DataOut to be written every other day. Also reworked how tables are called. Now all data tables are called at the end of the scan, outside of any If...Then statements
'20180406 - TAV Made a user-selectable variable when using the AutoRange function. Now, a user can decide how many bins to cut off at the surface based on their beamchecks. *ONCE IT HAS BEEN RATED, THIS VALUE SHOULD NOT CHANGE!*
'20180509 - TAV Increased WQ "SerialIn" instruction's Max Characters to account for a full suite of sensors/more than 1 parameter per sensor. Set the "GetVariablesFlag" to True in the "Initialize" Sub. Otherwise
'               it wouldn't get called if the system went down and rebooted.
'20180622 - TAV Fixed bug that was disallowing modem to cycle properly. Syntax around Conditional Compile statements regarding SW12 ports was not correct.
'20180706 - TAV Added code to detect "No Sonde" being returned from the SOA. This will put logger into Redeploy mode until a sonde is found.
'20180710 - TAV Added the TrueStage values to the keypad menu.
'               Fixed another Conditional Compile Syntax error regarding the Modem
'               Added SVMaq Table to allow techs to get field visit readings easier without having to scroll through the public table. SVMaq table only stores 1 record.
'               Added IsNClosed to USR variables.
'               Updated BiRating code to allow for use with 3-beam systems that aren't uplookers.
'20180823 - MRS Fixed bug for warning if U ports are used for VM or Sonde on the CR6 using the comms mode 0 option. Put Serialopen commands in subroutines.
'20180824 - MRS Eliminated "baudratehi" and VMbaud is now set in constant menu
'20181018 - TAV added battery voltages (Station, VM, and Wq Sonde) to Aquarius data tables. Added individual sensor stage values to AQ table and removed "StagePrime" and "StageSec". This selection will be done within Aquarius
'               so the changes can be tracked and managed more easily.
'20181114 - MRI created MaxBurstCnt constant, added into constant table so it can be changed more easily. Call burst table when MaxBurstCnt is met and write to Aqurius table.
'20181206 - TAV added Bi-directional rating variables into QAQC Table.
'20181219 - MRI added stagesecnd and selstgsecnd to 1min data table
'20190220 - TAV & MRI reworked entire WQ burst function/loop. It had been reporting 15min late and also not being triggered if the sonde missed the prior 1min punch.
'               Wrote logic to Exit the For...Next... loop if burst values were missed during the burst collection. Still working on logic to COUNT the actual number of values used for the burst. Unless something
'                      happens in the middle of the burst, it's been verified that 30 values are used.
'               Wrote table to sample every value every time through the Burst loop so we have a table stored with each individual sample to verify accuracy of the burst table.
'               Added StdDev, Min, and Max to Burst Table.
'               Now pull median values from the burst table using "MedTempC = Burst.BurstTempC_Med" to populate the AQ table. No sense in having two tables process the exact same functions.
'               Because of how the Median function works, we now "Round" the time of the mid point of the burst. Median is calculated by averaging the two median numbers if the total number of values is even.
'20190227 - MRI added logic to dermine what comms mode to us for the sonde based on if a Max232 was used or not. Current logic requires use of the C ports but additional flag of WQUseUPort may be added if testing shows U ports can be used for sonde communication
'                Due to differences in processing speed the CR1000 was set to use a longer period between samples while collecting burst data to avoid missing/shifting data
'           TAV updated the burst loop to exclude zeroes from the median calculation in the Burst table if there were issues with the communication. Total number of values used in the calculation also seems to be working correctly now.
'20190320 - MRI Added statement to conditional compile out the ADCPLoop if the HasVM is false to avoid potential timing problems
'20190325 - MRI Added BurstPeriod variable in public table so user can adjust the period length that is sent to the sonde during serial burst communication. Had it set to standard 1150 unless otherwise declared. Minimum value is 250. Presereve in USR file too.
'20190401 - TAV Added logic to record Turbidity NTUs (in addition to FNU) if it's a DWR sonde. Also added logic to set the time in PST if instead of UTC if it's a DWR sonde. They are using KOR 2, which makes the time output in local time (PST)
'20190408 - TAV Removed NTU logic per discussions and findings about how the YSI EXO reports the values. Reading is actually FNU. The only thing that changes is the 3 letter acronym, so it is inaccurate to report "NTU".
'20190409 - TAV Made the "Wq_Mark_Bad" function only occur if its a USGS sonde, not a DWR sonde in Sample and Hold mode.

'IMPORTANT - SDI-12 Code should be commented out if program is not being used at Freeport Sites.  If program is being used at freeport then the SlaveCom master slave code (used for fish recievers) MUST be commented out
'IMPORTANT - ADCP should be set for 1 minute TE and WP 60.
'IMPORTANT - For EXO2 serial operation, A MAX232 adapter must be used on CR6 "U" ports or CR1000 Com1.Com2,Com3 or Com4. An ADCP can run on all ports, but
'            a MAX232 adapter should probably be used if using CR6 "U" ports or for long RS232 cables.
SequentialMode 'must not use pipeline mode or averages are missed

'_____________________________Declare Public Variables___________________________________
Const Yes = True
Const No = False
'-------------------------------------------------------------------------------------------
'------------------------------------------------------------------------------------
'Customize constants explanation:
'WQSonde has the following choices"
' "NONE" is if there is no WQ Sonde installed at the station
' "WQ_SDI12" Choose if the WQ Sonde is SDI12
' WQ_Serial" Choose if the WQ Sonde is connected to the Serial port and No Burst is required
' "WQ_SERIAL_BURST" Choose if the WQ sonde is serial connected and Burst data is required
'"WQBaude" is the Sonde buadrate. 38400 or 9600.  38400 is preferred if Burst data is required
'"IsWQMax232" Choose if there is a MAX232 adapter on the Sonde Com port
'"IsVMMax232" Choose if there is a MAx232 adapter on the VM com port
'"IsSpecStudy" Choose if the VM is being used for a special velocity study
'"GetNoiseFloor" Choose if this is a sediment station and VM noise floor data is required
'"HasSlave" Choose if there is a slave datalogger attached that needs velocity and stage info
'"HasVM" Choose if there is a Velocity meter at this station
'"UseAutoRange" This will change EndBin based on water depth above transducer face for Uplooker sites
'"WQDeadCntMax" number of scans (1 min) of no WQ data before cycling power to the WQ sonde (5 to 120)
'VMDeadCntMax"  number of scans (1 min) of no VM data before cycling power To the VM (5 To 120)
'"StoreAllToCard"  Store all beam data (RSSI, Corr, Velocity) to Micro SD card (CR6) or CF card (CR1000)

'Change these values in the Tools/Customize Constants dropdown dialog
'do not change commented items in this customization section!!!!!!, they are like the keypad menu items.

'Start of Constants Customization Section
Const WqSonde = "WQ_SERIAL_BURST"
'Value = "WQ_SDI12"
'Value = "WQ_SERIAL"
'Value = "WQ_SERIAL_BURST"
'Value = "NONE"
Const DWRSonde = False
'value = True
'value = False
Const WqBaud = 38400
'value = 9600
'value = 38400
Const VmBaud = 38400
'value = 9600
'value = 19200
'value = 38400
'value = 57600
'value = 115200
Const IsWqMax232 = True
'value = True
'value = False
Const MaxBurstCnt = 30
'Min = 1
'Max = 30
'Inc = 1
Const MinBurstVals = 4
'Min = 1
'Max = 30
'Inc = 1
Const IsVmMax232 = False
'value = True
'value = False
Const IsSpecStudy = False
'value = True
'value = False
Const GetNoiseFloor = True
'value = True
'value = False
Const HasSlave = False
'value = True
'value = False
Const HasVM = True
'value = True
'value = False
Const UseAutoRange = False
'value = True
'value = False
Const WQDeadCntMax = 20
'Min = 5
'Max = 120
'Inc = 5
Const VMDeadCntMax = 20
'Min = 5
'Max = 120
'Inc = 5
Const StoreAllToCard = True
'value = True
'value = False
Const Debugging = False
'Value = True
'Value = False
Const SeeAllVel = False
'Value = True
'Value = False
Const SeeRawWQ = True
'Value = True
'Value = False
'End of Constants Customization Section

'------------------------------------------------------------------------------------------
'Constants to allow program to be used on CR1000 OR CR6 datalogger.
'in this preliminary version it's assumed that the CDMA uses SW12 no 1 on both dataloggers
'IMPORTANT! if using CR6 ports ComC1 or ComC3 use the device configuration utility to configure these ports for RS-232 (not TTL or other)
'-------------------------------------------------------------------------------------------------------------------------------------------
#If LoggerType = CR1000 Then
  Const AdcpPort = Com1
  Const WqSerialPort = Com4
  Const VMSwitchPort = 4 'only used if not using sw12
  Const WqSwitchPort = 6
  Const PS1Com3 = 3
  Const PS1Com5 = 5
  Const PS2Com3 = 3
  Const PS2Com5 = 5
  Const WqCom3 = 3
  Const wqCom5 = 5
  #If HasSlave = Yes Then
    Const SlaveCom = Com4
  #EndIf
  Const ExtPwrCom = 1
  Const ExtSolarCom = 2
#ElseIf LoggerType = CR6 Then
  Const AdcpPort = ComU1
  Const WqSerialPort = ComC1
  Const WqSwitchPort = U6
  Const UseSW12_2_forWQ = False
  Const VMSwitchPort = U4
  Const PS1Com3 = U3
  Const PS1Com5 = U5
  Const PS2Com3 = U3
  Const PS2Com5 = U5
  Const WqCom3 = U3
  Const wqCom5 = U5
  #If HasSlave = Yes Then
    Const SlaveCom = ComU7
  #EndIf
  Const ExtPwrCom = U11
  Const ExtSolarCom = U9
#EndIf


'Declare Constants
Const VelocityScaleWater = 1/304.8 'converts mm/sec to ft/sec
'constants for selecting different stage devices
Const ScanRate = 60
Const ScanUnit = 2
Const FastScanRate = 15
Const FastScanUnit = 2
Const UPbeam = 1
Const VMpress = 2
Const PSpress = 3
Const PSpress2 = 4
Const WqPress = 5
'data ID's
Const FixedLeaderID = 0 'data IDs located at the start of each data stream
Const VariableLeaderID = 128
Const CorrelationProfileID = 512
Const RSSIProfileID = 768
Const PGoodProfileID = 1024
Const VelocityProfileID = 256
Const VMStageID = 16384
Const BottomID = 1536
Const MaxBins = 27 'Changed back to 27 per JBD
Const MaxBeams = 4
Const BadVel = -32768 'bad velocity indicator from adcp
Const BadDataIndicator = NAN
Const Meters_to_Feet = 3.280839895
Const DegToRad = (3.14159265358979323846/180) 'degrees to radians

'Declare Misc Veriables
Public SiteID As String * 6 '3 character station identification
Public SiteNum As String * 16 'station number
Public CR1Volts As Float 'power supply voltage to cr10000
Public ExtWHConvertVolt As Float 'get volts from external power supply or battery pack
Public ExtSolarVolt As Float 'get volts from solar panel
Public PTempC As Float 'CR1000 panel temperature in DegC
Public PTempF As Float 'CR1000 panel temperature in Degf
Public BurstPeriod As Long 'give user ability to alter burst period in the public table
Public RecCalibData As Boolean 'flag to recored data at 1 minute interval when measurements are being done.
Public StoreVariablesFlg As Boolean
Public GetVariablesFlg As Boolean
Dim Rec15minFlag As Boolean 'set when Dataout table is stored
Public RecAQFlag As Boolean 'Set when problem with Sonde but still want to record to the Aquarius table
Dim Rec24HrFlag As Boolean 'set when QAQC table is stored
Dim Rec1MinFlag As Boolean 'set when recording Calibration data
Dim OneMinCount As Long 'used to turn off calibration data after 24 hours (1439 minnutes)
Dim RecDataFlag As Boolean 'used to check timing of ensemble data
Public RecAllVelFlag As Boolean 'used to set timing for velocity collecting in Special studies
Public VemcoRTR As Boolean 'used to set datalogger as "Master" in Master/Slave configurations (originially used for VEMCO deployments)
Public IsSubmersed As Boolean ''used to switch the function of the SW12V port so it's used for ADCP if the datalogger is in a submersible enclosure (with no relays, CDMA, etc.)
Public Prompt As String *5
'Dim RecBeamCheckFlag As Boolean 'flag to turn beamcheck table on or off
Public LowRatVel As Float' user input of lowest velocity covered by rating
Dim InitialLRV As Float ' used for changing LowMeas flag to false if there's been a change to the LowRatVel
Public HighRatVel As Float' user input of Highest velocity covered by rating
Dim InitialHRV As Float 'used for changing HighMeas flag to false if there's been a change to the HighRatVel
Public LowMeas As Boolean 'flag indicating low flow measurement needed
Public HighMeas As Boolean 'flag indicating high flow measurement needed
Dim LowCount As Long 'counter for number of times velocity is below the Lower limit
Dim HighCount As Long 'Counter for number of times velocity is above the upper limit
Public VMPower As Boolean 'flag to turn VM on and Off manually
Public isVMNClosed As Boolean 'is the VM powered using a Normally clo9sed relay
Public VmDeadCount As Long 'number of times VM has bad data
#If Debugging = True Then
  Public UseCommsZeroForADCP As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the ADCP
  Public UseCommsOneForSonde As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde
  Public UseCommsZeroForSonde As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde
  Public WqUseCPort As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde. Future version may allow U ports too.
#Else
  Dim UseCommsZeroForADCP As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the ADCP
  Dim UseCommsOneForSonde As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde
  Dim UseCommsZeroForSonde As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde
  Dim WqUseCPort As Boolean 'Used to set comms mode when C1,C3 com ports are used on the CR6 for the Sonde. Future version may allow U ports too.
#EndIf
'Declare variables to hold time values
Dim rTime(9) As Float 'this array holds time values returned from the realtime statement
Alias rTime(3) = DOM 'FOR BEAM CHECK
Alias rTime(4) = Hour
Alias rTime(5) = Minute
Alias rTime(6) = Second
Alias rTime(7) = MicroSecond
Public LastScan As String * 6 'when did the datalogger most recently scan?
Dim RealSeconds As Long 'used for computing elapsed time intervals
Dim Mod5Minutes As Long 'used for computing elapsed time intervals
Dim Mod15Minutes As Float 'used for computing elapsed time intervals
Dim Mod60Minutes As Float 'used for computing elapsed time intervals
Dim ModDay As Float 'used for computing elapsed time intervals
#If Debugging = True Then
  Public VMYear As Long 'Date time from the Velocity meter clock
  Public VMMonth As Long 'Date time from the Velocity meter clock
  Public VMDay As Long 'Date time from the Velocity meter clock
  Public VMHour As Long 'Date time from the Velocity meter clock
  Public VMMinute As Long 'Date time from the Velocity meter clock
  Public VMSecond As Long 'Date time from the Velocity meter clock
  Public VMTime As String * 25 'Date time from the Velocity meter clock
  Public SetVMTimeFlg As Boolean 'used it setting VM Time
  Public VMTimeString As String * 25 'used it setting VM Time
  Public SplitTime(6) As Float 'used it setting VM Time
  Public RawSetTime As String * 25 'used it setting VM Time and EXO time
  Public FSplitTime(6) As Float 'used it setting VM Time
#Else
  Dim VMYear As Long 'Date time from the Velocity meter clock
  Dim VMMonth As Long 'Date time from the Velocity meter clock
  Dim VMDay As Long 'Date time from the Velocity meter clock
  Dim VMHour As Long 'Date time from the Velocity meter clock
  Dim VMMinute As Long 'Date time from the Velocity meter clock
  Dim VMSecond As Long 'Date time from the Velocity meter clock
  Dim VMTime As String * 25 'Date time from the Velocity meter clock
  Dim SetVMTimeFlg As Boolean 'used it setting VM Time
  Dim VMTimeString As String * 25 'used it setting VM Time
  Dim SplitTime(6) As Float 'used it setting VM Time
  Dim RawSetTime As String * 25 'used it setting VM Time and EXO time
  Dim FSplitTime(6) As Float 'used it setting VM Time
#EndIf
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Public EXOTimeString As String * 25
  Public SetEXOTimeFlg As Boolean
#EndIf

'spike filter variables
#If HasVM Then
  Dim RSSIspike(MaxBins,4,16) As Float 'array to hold RSSI data Queue
  Dim Corrspike(MaxBins,4,16) As Float 'array to hold Correlation data Queue
  Dim Velspike(MaxBins,4,16) As Float 'array to hold Velocity data Queue
  Dim StageSpike(16) As Float 'array to hold Stage data Queue
  Public QueueDQI As Float 'data quality indicator for Queue
  Public RSSIStdNo As Long = 2  ' standard deviations from mean for spike
  Public CorrStdNo As Long = 2
  Public VelStdNo As Long = 2
  Public SpikeFileName As String * 64
  Dim FileHandle As Long
  Public FileHeader As String * 500
  Public SpikeCounter As Long
  Public SendHeader As Boolean = True
  Public TestTime As String * 20
  Public CardError As String * 25
#EndIf

'Declare variables for CDMA
Dim CdmaScans As Long 'number of times the datalogger has unsuccessfully attempted to connect to the loggernet server
Public HrsCdmaOff As Long 'how many hours to allow to pass before trying to restart the CDMA if there are connection issues
Dim LoggernetAddr As Long 'LoggerNet server PakBus address (generally 4094). if datalogger doesn't see this address as a "neighbor" it assumes connection failure
'which is used for knowing when to reset CDMA (using the variables above)
Public CdmaWorks As Boolean 'using the above variable "LoggernetAddr", does the datalogger see 4094 as a neighbor? if not, it's assumed CDMA does not work
Dim CDMAFailure As Boolean 'indicator of a CDMA failure for triggering a reset
Public CycleCdmaPwr As Boolean 'cycle the power to the CDMA
Public IsCDMAOn As Boolean 'Is the CDMA powered? (based on the switch 12V port status, (on or off), and the "IsNClosed" variable
Public IsCDMANClosed As Boolean 'Is there a Normally Closed Relay installed in the CDMA circuit, if yes, SW12V port stays OFF to keep power to CDMA. if no, SW12V port
'stays ON to power the CDMA
Public KeepCDMAon As Boolean 'keep CDMA 24/7 (true) or turn on at the top of the hour for 10 minutes to save battery power (false)

'Declare variables to hold system status information
Public Tech As String * 3 'user initials so we know who was there for a visit
Public VisitReason As String *100 'what is the purpose of the visit
Public SerNum As Long 'datalogger computer serial number
Public OSVers As String * 18 'datalogger Operating System version
Public Program As String * 25 'Program version
Public ProgVersDate As String * 8 'date of the program version, based on the constant "ProgramVersionDate"
Public ProgErrors As Long 'from "Status" table, The number of compile or runtime errors for the current program.
Public Low12Volts As Long 'from "status" table, how many times has there been low voltage (based on CR1000 threshold of 9.6v when the CR1000 goes into a lower power
'mode and discontinues it's measurement tasks until power is restored)
Public LithBat As Float 'voltage of the internal lithium battery. (this battery keeps memory in case of external power issues)
Public SkipScans As Long 'number of times a complete scan has been skipped (with the exception of intentionally skipped scans based on ExitScan and Do/Loops
Public FreeCFMem As Float 'how much memory does the external CF card have remaining

Public ErrorEvent As String * 100 'what caused the automated "SiteVisit" table to be written?
Public Coord As String * 20 'which coordinate system is the ADCP using?
Dim ADCPSN01 As Long 'the following "ADCPSNxx" are used to have a record of which serial number is being used and if it's been changed
Dim ADCPSN02 As Long
Dim ADCPSN03 As Long
Dim ADCPSN04 As Long
Public AdcpSN As Long
Dim InitialAdcpSN As Long 'used to hold the previous day's serial number and flag it if the instrument has changed
Public NewADCP As Boolean 'is it a new ADCP?
Public PS1SN As String * 40 'used to get pressure sensor brand, model, and serial number
Dim InitialPS1SN As String * 40 'used to hold the previous day's serial number and flag it if the instrument has changed
Public NewPS1 As Boolean 'is it a new pressure sensor?
Public PS2SN As String * 40 'used to get pressure sensor brand, model, and serial number
Dim InitialPS2SN As String * 40 'used to hold the previous day's serial number and flag it if the instrument has changed
Public NewPS2 As Boolean 'is it a new pressure sensor?

'Decoding Velocity variables
Public BadChecksum As Long 'if
Public HeaderMismatch As Long
Dim NumbytesZero As Long
Public CalcCheckSum As Float
Public EnsChecksum As Float
Dim TempL As Long
'Public Numbytes
Public BadEnsemble As Long
Public ScanNo As Long
Dim Longarray(2000) As Long 'Array for the Raw Ensemble
'Dim Nums(2) As Long
Public EnsembleLen As Long
Dim Datatypes As Long
Dim Offsets(25) As Long 'offsets to the start of the datatype locations
Public BinSize As Long 'ADCP bin size in centimeters
Public NumADCPBins As Long 'ADCP number of bins
Public Numbins As Long 'number of adcp bins used
Public EnsPings As Long 'Number of acoustic pings per ensemble
Public NumBeams As Long 'Number of beams on ADCP
Public BlankDist As Long 'Blanking distance of ADCP
Public EX As Long 'coordinate transformation
Public ES As Long 'Salinity
Public Decode As String * 70
'Public FramingError As Long
Dim FixedLeadOffset As Long
Dim MSB As Long
Dim MSB1 As Long
Dim LSB As Long
Dim ReceivedBytes As Long
Dim TempId As Long 'for testing
'Dim UseAutoLastBin As Boolean
Public UseDir As Boolean 'does the user want to use compass direction of flow to indicate flood or ebb?
Public PosFlowDir As Float 'what is the compass bearing that indicates a positive flow? (outgoing flow)
Public RecordAll As Boolean
Public PreserveFile As String * 500
'Declare Vel and Q variables
Public CalcQ As Boolean 'user select whether to calculate discharge or not
Public UseV2 As Boolean
Public IndexVel As Float 'index velocity based on rating
Public MeanVel As Float 'average channel velocity based on all bin data
Public Qcfs As Float 'total discharge
Public BadQCount As Long 'how many times has the datalogger been unable to calculate discharge? (either bad stage value or bad velocity value)
Public MinExpVel As Long 'minimum velocity expected at site
Public MaxExpVel As Long 'maximum velocity expected at site
Public FlowSign As Long 'positive or negative multipler depending on which side of the channel the instrument is on
Public BadVelCount As Long 'how many times has there been bad velocity?
Public BadBinCnt As Long
Public DataErr As Long
Public BadVelFlag As Boolean 'indicates there was a data punch with invalid velocity
Public BadQFlag As Boolean 'indicates there was a data punch with invalid discharge
Dim VelDatOffset As Long 'Velocity offset (location of the beginning of velocity data
Dim Bin As Long 'counters for bins
Public StartBin As Long 'where the datalogger begins its iVel calculation
Public StartEbbBin As Long' Use if using ebb and flood rating
Public EndEbbBin As Long' Use if using ebb and flood rating
Public StartFldBin As Long' Use if using ebb and flood rating
Public EndFldBin As Long' Use if using ebb and flood rating
Public EndBin As Long 'where the datalogger ends its iVel calculation
Public BiRating As Boolean = False 'Use this flag if using Ebb/Flood rating
Public BiRatOK As Boolean = False 'Used by program to determin if BiRating can be done
Public UseBiRat As Boolean = False 'flag set if both the above are true
Public BiRatTran As Float  'Transition velocity for ebb/flood Rating
Dim Beam As Long 'counters for beams
Dim temp As Long 'temporary variable
Dim Index As Long 'temporary variable
Dim BinVel As Float 'test variable
Dim BinStep As Long 'counter variable
Dim EnsBin As Long 'counter variable
Dim ensVelocity(MaxBins,4)As Float '30 bins, and 4 beams max Velocity Data
#If SeeAllVel = True Then
  Public V1(MaxBins) As Float 'Can be either Beam 1 velocity, X velocity, or East velocity
  Public V2(MaxBins) As Float 'Can be either Beam 2 velocity, Y velocity, or North velocity
  Public V3(MaxBins) As Float 'Can be either Beam 3 velocity, Z velocity, or UP velocity
  Public V4(MaxBins) As Float 'Can be either Beam 4 velocity, or Error velocity
  Public VMBinVel(MaxBins) As Float 'Up/Dowm stream velocity in each bin
#Else
  Dim V1(MaxBins) As Float 'Can be either Beam 1 velocity, X velocity, or East velocity
  Dim V2(MaxBins) As Float 'Can be either Beam 2 velocity, Y velocity, or North velocity
  Dim V3(MaxBins) As Float 'Can be either Beam 3 velocity, Z velocity, or UP velocity
  Dim V4(MaxBins) As Float 'Can be either Beam 4 velocity, or Error velocity
  Dim VMBinVel(MaxBins) As Float 'Up/Dowm stream velocity in each bin
#EndIf

Dim VelCount As Long 'counter for number of velocity measurements
Dim BadBinCount As Long

'Velocity Averaging Variables  NOTE! EBB FLOOD RATINGS CAN ONLY BE USED WITH CHANNEL MASTERS SET TO INSTRUMENT COORDINATES
Dim V1Sum As Float 'sum of bins in each ensemble for V1
Dim V1EbbSum As Float ' sum of bins in each ensemble for V1 in positive dir
Dim V1FldSum As Float ' sum of bins in each ensemble for V1 in Neg dir
Dim V2Sum As Float 'sum of bins in each ensemble for V2
Dim V2EbbSum As Float ' sum of bins in each ensemble for V2 in positive dir
Dim V2FldSum As Float ' sum of bins in each ensemble for V2 in Neg dir
Dim V3Sum As Float 'sum of bins in each ensemble for V3
Dim V4Sum As Float 'sum of bins in each ensemble for V4
Dim V1Disable(MaxBins) As Boolean
Dim V2Disable(MaxBins) As Boolean
Dim V3Disable(MaxBins) As Boolean
Dim V4disable(MaxBins) As Boolean
Dim VmBinVelDisable(MaxBins) As Boolean
Public V1AVG As Float 'average of bins in each ensemble for V1
Dim V1EbbAvg As Float 'average of bins in each ensemble for V1 for pos dir
Dim V2EbbAvg As Float 'average of bins in each ensemble for V2 for pos dir
Public V2AVG As Float 'average of bins in each ensemble for V2
Dim V1FldAvg As Float 'average of bins in each ensemble for V1 for Neg dir
Dim V2FldAvg As Float 'average of bins in each ensemble for V2 for Neg dir
Public V3AVG As Float 'average of bins in each ensemble for V3
Public V4AVG As Float 'average of bins in each ensemble for V4
Dim Cnt As Long
Public V1Cnt As Long
Dim V1EbbCnt As Long
Dim V2EbbCnt As Long
Dim V1FldCnt As Long
Dim V2FldCnt As Long
Dim V2Cnt As Long
Dim V3Cnt As Long
Dim V4Cnt As Long
Const rad = 3.14159/180
Const deg = 180/3.14159

'Decoding Variable leader
Dim VarLeadOffset As Long '---data variables from variable leader---
Public BIT As Long
Public EnsembleNo As Long

'Decoding RSSI Data
Dim RSSIDatOffset As Long   'location of start of RSSI data
Dim ensRSSI(MaxBins,4) As Long  'MaxBins bins and 4 beams max  RSSI Data
Dim nRSSI As Long 'for RSSI average calc
Dim AccumRSSI As Long 'for RSSI average calc
Dim AvgRSSI(MaxBins) As Long 'average of all beams for that bin per ensemble
Public AvgRSSIStartBin As Long
Public AvgRSSIEndBin As Long
Dim AvgRSSIcounter As Long
Dim AvgRSSIAccum As Long
Public AvgSwathRSSI As Float

'Decoding Correlation Magnitude
Dim CorrDatOffset As Long 'location of start of correlation data
Dim ensCorr(MaxBins,4) As Long '25 bins and 4 beams max Correlation Data
'Dim TempCorr(4) 'temporary array for calculating standard deviation of Correllation
Dim nCorr As Long
Dim AccumCorr As Long
Dim AvgCorr(MaxBins) As Long 'average of all beams for that bin per ensemble
'Dim StdDevCorr(MaxBins) As Float 'holder for std dev of 4 beam correlation

'Decoding Channel Master and Workhorse Stage
Public VMStageDatOffset As Long
Dim L1SB As Long
Dim M1SB As Long
Dim TempM As Float
#If Debugging = True Then
  Public VMTemp As Long 'temporary debugging variable
  Public VMPSTemp As Long 'temporary debugging variable
  Public WHPSTemp As Float 'for workhorse pressure
  Public WHTempM As Float
  Public WHTempK As Float
#Else
  Dim VMTemp As Long 'temporary debugging variable
  Dim VMPSTemp As Long 'temporary debugging variable
  Dim WHPSTemp As Float 'for workhorse pressure
  Dim WHTempM As Float
  Dim WHTempK As Float
#EndIf

'System Identification
Public IsCM As Boolean
Public IsVADCP As Boolean
Public IsWorkhorse As Boolean


'Data Filtering Variables
Public SelectFilter As Long
Public RangedBin As Long = 0 'holder for last bin before surface corruption
Public DucerDepthOffset As Float' difference between depth sensor and transducer face. (+/-) - if lower than ducer + if higher
Public RangeSource As Long 'sensor source for ducer depth calculation
Public CutOffBins As Long 'user enterable value for number of bins to discard when using AutoRange feature for uplookers
'Dim cntBin As Long 'counter for LastGoodBin Check
'Dim cntBin2 As Long 'second counter for LastGoodBin Check
Public RSSIThreshold As Float 'allows user to set RSSI Threshold
Public StdCorrThreshold As Float 'allows user to set stddev threshold for correlation of 4 beams
Public CorrThreshold As Float
'Dim TestEns As Long
'Dim EnsLoop As Long
'Dim AvgRunEns As Float
'Dim RunEnsSpikes As Long
Dim BadEnsCount As Long
'Dim BadEnsFlag As Boolean
Dim LoopInterval As Long
Dim FastLoopInterval As Long

'Declare Event variable flags
Dim EventCDMAFlag As Boolean 'added so cdma cycle is only recorded every 24 hours
Dim EventVoltFlag As Boolean '  '   '  Low Voltage  "       "       "      "
Dim EventYSIFlag As Boolean  '   "   " BadYSI = 200  "     "        "      "
Dim EventQFlag As Boolean    '   "   " BadQ = 200    "     "        "      "

'Declare Stage and Area Variables
Public PSPressPort As Long 'port Pressure sensor 1 is plugged into (3 or 5)
Public PSPressAddr As Long 'SDI12 address for Pressure sensor 1
Public PSPressDataIn As Boolean 'are there data from Pressure sensor 1?
Public PsPress1Stg(2) As Float 'array to hold the values pressure sensor 1 is outputting (temp and feet)
Alias PsPress1Stg(1) = PS1RawDepthFt 'Label array as easy-to-read values for techs
Alias PsPress1Stg(2) = PS1TempC
Public PSpress2Stg(2) As Float 'array to hold values pressure sensor 2 is outputting
Alias PSpress2Stg(1) = PS2RawDepthFt 'Label array as easy-to-read values for techs
Alias PSpress2Stg(2) = PS2TempC
Public PSpress2Port As Long 'port pressure sensor 2 is plugged into (3 or 5)
Public PSpress2Addr As Long 'SDI12 address for pressure sensor 2
Public PSpress2DataIn As Boolean 'are there data from pressure sensor 2?
Public StagePrime As Float 'stage value used in calculating discharge
Public StageSecnd As Float 'stage value used in calculating stage difference
Public StgDiff As Float 'absolute value of difference between StagePrime and the user selected instrument stage
Public UpBeamStg As Float 'stage value (after offset applied) for ADCP vertical beam
Public VMPressStg As Float 'stage value (after offset applied) for ADCP pressure sensor
Public PS1Stg As Float ''stage value (after offset applied) for pressure sensor 1
Public PS2Stg As Float ''stage value (after offset applied) for pressure sensor 2
Public SondeStg As Float ''stage value (after offset applied) for YSI or EXO sonde
Public TrueUpBeamStg As Float 'user input stage reference to calculate (and apply) offset to raw upbeam data to output "UpBeamStg"
Public TrueVMPressStg As Float 'user input stage reference to calculate (and apply) offset to raw ADCP pressure sensor data to output "VMPressStg"
Public TruePS1Stg As Float 'user input stage reference to calculate (and apply) offset to raw Pressure sensor 1 data to output "PS1Stg"
Public TruePS2Stg As Float 'user input stage reference to calculate (and apply) offset to raw pressure sensor 2 data to output "PS2Stg"
Public TrueSondeStg As Float 'user input stage reference to calculate (and apply) offset to raw YSI data to output "YsiStg"
Dim SelStgPrime As String 'which of the 5 stage options is used to calculate discharge
Public SelStgSecnd As String 'Which of the 5 stage options is used to calculate stage difference
Public UpBeamOffset As Float 'offset applied to raw data to get stage value
Public VMPressOffset As Float'offset applied to raw data to get stage value
Public PS1Offset As Float'offset applied to raw data to get stage value
Public PS2Offset As Float'offset applied to raw data to get stage value
Public SondeOffset As Float'offset applied to raw data to get stage value
Public StgSelect As String 'numerical indicator of which instrument is being used to calculate discharge within the datalogger
Public Area As Float 'calculated channel area based on stage-area rating
Public BadStgFlag As Boolean 'indicates bad stage value
Public BadStgCount As Long 'indicates number of times bad stage values have occured
Public MaxExpStg As Long 'maximum expected stage
Public MinExpStg As Long 'minimum expected stage

'Declare Rating Variables
'Should we make these arrays for easier output?
Public StgOffset As Float 'stage-area equation coefficient
Public StgCoef As Float 'stage-area equation coefficient
Public StgCoef2 As Float 'stage-area equation coefficient
Public VelOffset As Float 'iVel equation coefficient
Public VelCoef As Float 'iVel equation coefficient
Public VelCoef2 As Float 'iVel equation coefficient
Public VelCoef3 As Float 'iVel equation coefficient
Public UpVelOffset As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public UpVelCoef As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public UpVelCoef2 As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public UpVelCoef3 As Float 'iVel equation coefficient for velocities above transition point (in break point rating)
Public LowVelOffset As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public LowVelCoef As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public LowVelCoef2 As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public LowVelCoef3 As Float 'iVel equation coefficient for velocities below transition point (in break point rating)
Public Trans As String * 4 'Transition point in velocity where iVel calulation decides to use upper or lower rating equation
'                           Float was used, changed to a 3 character string in case someone accidentally types a number in, this will allow user to revert back to "NAN" -TAV 20141208
'declare variables for EXO and SDI
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Public WqNparams = 23
  Public Redeploy As Boolean
  Public NoSondeTrig
  Public GetBurst As Boolean
  Public BurstTimeReached As Float 'holder to see when we're reaching the burst time
  Public BurstReachedMod As Float
  Public BurstComs As String * 10000
  '  Public TestMedBurstTime
  '  Public OldBurstTime
  '  Public NewBurstTime
  Public OldEXOTime As Long
  'Exo Parameter Codes from EXO manual. These are used to determine where to put the EXO sensor data.
  Dim DateCode = 52
  Dim TimeCode = 54
  Dim TempCCode = 1
  Dim TempFCode = 2
  Dim CondCode = 7
  Dim TurbFNUCode = 223
  Dim DoSatCode = 211
  Dim DOmgLCode = 212
  Dim DepthCode = 23
  Dim BattCode = 28
  Dim pHCode = 18
  Dim pHmVCode = 17
  Dim ChlugLCode = 193
  Dim ChlRFUCode = 194
  Dim BGApcRFUCode = 216
  Dim BGApcugLCode = 225
  Dim FDomRFU = 227
  Dim FDomQSU = 228
  Dim ORPCode = 19
  Dim NH4Code = 48
  Dim CLCode = 112
  Dim NO3Code = 106
  Dim WiperPos = 229

  #If WqSonde = "WQ_SERIAL_BURST" Then
    Public BurstData(23)
    Dim BurstArray(30,23)
    Public BurstIn As String * 256 'Raw EXO burst data string
    Public jCount As Long 'Counter
    Public kCount As Long 'Counter
    Public BurstCount As Long 'number of burst measurements collected
    '    Public BurstCount_Mid
    Public GotToBurst 'debugging, how many times did we reach the burst function
    Public TotalBurstVals 'how many values are actually used to calculate the burst math functions
    Public BurstErrCnt 'how many times during the burst loop did we miss data
    Public BurstMaxErrCnt = 3 'threshold for how many times we can miss before exiting the burst loop
    Public BurstMissed As Boolean 'flag if we missed the burst due to missing too many values
    Public BurstDebugCount As Long 'Debugging EXO burst!----------------------------------------------
    Public BurstDate
    Public BurstTime
    Public BurstTempC
    Public BurstTempF
    Public BurstSpCond
    Public BurstTurbFNU
    Public BurstDOSat
    Public BurstDOmgL
    Public BurstORP
    Public BurstDepthFt
    Public BurstBattV
    Public BurstpH
    Public BurstpHmV
    Public BurstChlugL
    Public BurstChlRFU
    Public BurstBGApcRFU
    Public BurstBGApcugL
    Public BurstFdomRFU
    Public BurstFDomQSU
    Public BurstNH4Amgl
    Public BurstNO3Nmgl
    Public BurstCLmgl
    Public BurstWiperPos

    '____________________________Median variables to be pulled from Burst table and stored to output in AQ Table_____________
    Public MedBurstDate
    Public MedBurstTime
    Public MedTempC
    Public MedTempF
    Public MedSpCond
    Public MedTurbFNU
    Public MedDOSat
    Public MedDOmgL
    Public MedORP
    Public MedDepthFt
    Public MedBattV
    Public MedpH
    Public MedpHmV
    Public MedChlugL
    Public MedChlRFU
    Public MedBGApcRFU
    Public MedBGApcugL
    Public MedFdomRFU
    Public MedFDomQSU
    Public MedNH4Amgl
    Public MedNO3Nmgl
    Public MedCLmgl
    Public MedWiperPos
  #EndIf 'EXO data that's been parsed
  #If SeeRawWQ = True OR Debugging = True Then
    Public t(23)
    Public WqData(23)
    Public WqIn As String * 256 'Raw EXO data string
    Public WqDelay As Long 'Used as place holder for timer to know how long the wiper is wiping
    Public RecBurstFlag As Boolean
  #Else
    Dim t(23)
    Dim WqData(23)
    Dim WqIn As String * 256 'Raw EXO data string
    Dim WqDelay As Long 'Used as place holder for timer to know how long the wiper is wiping
    Dim RecBurstFlag As Boolean
    'Public RecAquariusFlag As Boolean
    'Dim ExoBaud 'Variable to use in the "SerialOpen" instruction for the EXO
  #EndIf
  'Dim TempLong As Long 'Placerholder for timer
  Public WipeTime As String * 25 'Time/Date that the wiper finishes its wipe
  Public WqParamOrder(23) 'Array that holds the Wq Codes to help determine what order the data are coming in.
  Public WqLocDate
  Public WqLocTime
  Public WqLocTempC
  Public WqLocTempF
  Public WqLocCond
  Public WqLocTurbFNU  
  Public WqLocDoSat
  Public WqLocDOmgL
  Public WqLocORP
  Public WqLocDepth
  Public WqLocBatt
  Public WqLocpH
  Public WqLocpHmV
  Public WqLocChlugL
  Public WqLocChlRFU
  Public WqLocBGApcRFU
  Public WqLocBGApcugL
  Public WqLocFDomRFU
  Public WqLocFDomQSU
  Public WqLocNH4
  Public WqLocNO3
  Public WqLocCL
  Public WqLocWiperPos
  Public Wipeflag As Boolean
  'Exo Error variables
  '  Public ExoError As Boolean
  '  Public ExoDead As Boolean
  '  Public ExoErrorCnt
#EndIf
'Declare Variables for SDI12 Sonde
'Data from YSIsond comes into the wqSDI12Sensor array (in a certain order, based on YSI settings),
'user selects which order they come in using these variables. Datalogger puts values in correct location
#If WqSonde = "WQ_SDI12" Then
  Public WqSDI12Sensor(23)
  Public Wiper1Min As Float
  Public WiperTestCount As Float
  Public WiperInCount As Float
  'Public LocDate As Long 'may be used in the future
  'Public LocTime As Long 'may be used in the future
  Public LocTempC As Long
  Public LocSpCond As Long
  Public LocTurbFNU As Long
  Public LocVolts As Long
  Public LocDOmgL As Long
  Public LocDOSat As Long
  Public LocPH As Long
  Public LocORP As Float
  Public LocDepth As Long
  Public LocChlorMGL As Long
  Public LocChlorRFU As Long
  Public LocBGA As Float
  Public LocFdomRFU As Float
  Public LocFdomQSU As Float
  Public LocAmmonium As Float
  Public LocNitrate As Float
  Public LocChloride As Float
  Public LocWiperPos As Float
  Public WqAddr As Long 'SDI12 address of the YSI
  Public WqSDIPort As Long 'Port YSI is plugged into (C3 or 5 for CR1000, U3 or 5 for CR6)
  Public WiperErrCount As Float
  Public WiperOut As Boolean
  'Dim WqSdiErr As Boolean 'indicator for data not coming in
  Public MilliToMicro As Boolean 'does the Specific Conductance need a multiplier to make the value millisiemens to microsiemens?
#EndIf

'Declare universal variables for the sondes, only populate variables if a sonde is present
#If (WqSonde <> "NONE") Then
  'Public WqSerPort As String
  'Public WqAddr As String
  Public TempDiff As Float
  Public WqError As Boolean
  Public WqDead As Boolean
  'Public WqDeadCnt As Long
  Public WqBadData As Boolean
  Public WqDate As String
  Public WqTime As String
  'Public WqNparams As Long
  Public WqTempC As Float
  Public WqTempF As Float
  Public WqSpCond As Float
  Public WqTurbFNU As Float
  Public WqChlugL As Float
  Public WqChlRFU As Float
  Public WqDOMgl As Float
  Public WqDOSat As Float
  Public WqPH As Float
  Public WqPHmv As Float
  Public WqORP As Float
  Public WqDepthFt As Float
  Public WqBattV As Float
  Public WqBGAugl As Float
  Public WqBGArfu As Float
  Public WqFDOMrfu As Float
  Public WqFDOMqsu As Float
  Public WqNH4mgl As Float
  Public WqNO3mgl As Float
  Public WqCLmgl As Float
  Public WqWiperPos As Float
  Public WqErrCount As Long
  Public WqPwrCycleCnt As Long
  Public WqManualCycle As Boolean
#EndIf
Public IsWQNClosed As Boolean 'Keep this outside conditional compile until we take time to actually fix it. Works like this though.
'variables for aquarius table
Public AvgIndexVel As Float
Public AvgVMTemp As Float
Public AvgVMPitch As Float
Public AvgVMRoll As Float
Public AvgPS1Stg As Float
Public AvgPS2Stg As Float
Public AvgUpBeamStg As Float
'Public AvgLoggerQcfs As Float
'Public AvgLoggerMeanVel As Float  Maybe bring this into Aquarius for internal use if we deem it necessary?
'Public AvgStagePrime As Float
'Public AvgStageSec As Float

'Public WqSondeDead As Boolean 'indicator that the YSI is flatlined or out
'Public WqSondeDeadCnt As Long 'how long has it been flatlined or out?
'Public WqErrCount As Long
'Public WqError As Boolean


'Declare variables for velocity meter data
Public VMtempF As Float
Public VMupBeam As Float
Public VMpressure As Float
Public WHpressure As Float
Public VMHeading As Float
Public VMpitch As Float
Public VMroll As Float
Public VMVolts As Float
Public VMtempC As Float
Public VMdataIn As Boolean


'-------------------------------------------------------DEBUGGIMG!!!!!-------------------------------------------------
#If Debugging = True Then
  Public DepthMSB As Long 'debugging variables
  Public DepthMSB1 As Long'debugging variables
  Public DepthLSB As Long'debugging variables
  Public DepthLSB1 As Long'debugging variables
  Public IDwords(14) As Long
  Public LSBTemp As Long
  Public LSB1Temp As Long
  Public MSBTemp As Long
  Public MSB1Temp As Long
  Public Subscans As Long
  Public EnsBytes As Long
  Public MissedEns As Long
  Public ADCPLoop As Long
  Public ADCPDone As Boolean
  Public ScanDiff As Long
  Public DebugTime(9) 'DEBUGGING START TIME OF SCANS
  Alias DebugTime(3) = DayOfMnth
  Alias DebugTime(4) = Hours
  Alias DebugTime(5) = Minites
  Alias DebugTime(6) = Secints
  Alias DebugTime(7) = MicSec
  Public ScanStart
  Public ScanEnd
  Public ADCPEnd
  Public BeforeBurst
  Public AfterBurst
  Public CDMACheckStart
  Public CDMACheckEnd
  Public CDMACheckTotTime
  Public ZeroVMTimeStart
  Public ZeroVMTimeEnd
  Public ZeroVMTotTime
  Public ChkSumChkStart
  Public ChkSumChkEnd
  Public ChkSumChkTotTime
  Public MainDecodeStart
  Public MainDecodeEnd
  Public MainDecodeTotTime
  Public CalcRangeStart
  Public CalcRangeEnd
  Public CalcRangeTotTime
  Public OneMinCalcStart
  Public OneMinCalcEnd
  Public OneMinCalcTotTime
  Public CalcQStart
  Public CalcQEnd
  Public CalcQTotTime
  Public GetVMMemStart
  Public GetVMMemEnd
  Public GetVMMemTotTime
  Public VMTimeStart
  Public VMTimeEnd
  Public VMTotTime
  Public CallBmChkStart
  Public CallBmChkEnd
  Public CallBmChkTotTime
  Public DataTabsStart
  Public DataTabsEnd
  Public DataTabsTotTime
  Public DataOutStart
  Public DataOutEnd
  Public DataOutTotTime
  Public Data1mStart
  Public Data1mEnd
  Public Data1mTotTime
  Public AQTabStart
  Public AQTabEnd
  Public AQTabTotTime
  Public StoreToCrdStart
  Public StoreToCrdEnd
  Public StoreToCrdTotTime
  Public ChkSpikeStart
  Public ChkSpikeEnd
  Public ChkSpikeTotTime
  Public AddSpikeStart
  Public AddSpikeEnd
  Public AddSpikeTotTime
  Public ProcessTime
  Public DataOutCount
  Public AQcount
  Public Data1mCount
  Public CardBadCount
  Public CardOkCount
#Else
  Dim DepthMSB As Long 'debugging variables
  Dim DepthMSB1 As Long'debugging variables
  Dim DepthLSB As Long'debugging variables
  Dim DepthLSB1 As Long'debugging variables
  Dim IDwords(14) As Long
  Dim LSBTemp As Long
  Dim LSB1Temp As Long
  Dim MSBTemp As Long
  Dim MSB1Temp As Long
  'Dim Subscans As Long
  'Dim EnsBytes As Long
  Dim MissedEns As Long
  'Dim ADCPLoop As Long
  'Dim ADCPDone As Boolean
  Dim ScanDiff As Long
  Dim DebugTime(9) 'DEBUGGING START TIME OF SCANS
  Alias DebugTime(3) = DayOfMnth
  Alias DebugTime(4) = Hours
  Alias DebugTime(5) = Minites
  Alias DebugTime(6) = Secints
  Alias DebugTime(7) = MicSec
  Dim ScanStart
  Dim ScanEnd
  Dim ADCPEnd
  Dim BeforeBurst
  Dim AfterBurst
  Dim CDMACheckStart
  Dim CDMACheckEnd
  Dim CDMACheckTotTime
  Dim ZeroVMTimeStart
  Dim ZeroVMTimeEnd
  Dim ZeroVMTotTime
  Dim ChkSumChkStart
  Dim ChkSumChkEnd
  Dim ChkSumChkTotTime
  Dim MainDecodeStart
  Dim MainDecodeEnd
  Dim MainDecodeTotTime
  Dim CalcRangeStart
  Dim CalcRangeEnd
  Dim CalcRangeTotTime
  Dim OneMinCalcStart
  Dim OneMinCalcEnd
  Dim OneMinCalcTotTime
  Dim CalcQStart
  Dim CalcQEnd
  Dim CalcQTotTime
  Dim GetVMMemStart
  Dim GetVMMemEnd
  Dim GetVMMemTotTime
  Dim VMTimeStart
  Dim VMTimeEnd
  Dim VMTotTime
  Dim CallBmChkStart
  Dim CallBmChkEnd
  Dim CallBmChkTotTime
  Dim DataTabsStart
  Dim DataTabsEnd
  Dim DataTabsTotTime
  Dim DataOutStart
  Dim DataOutEnd
  Dim DataOutTotTime
  Dim Data1mStart
  Dim Data1mEnd
  Dim Data1mTotTime
  Dim AQTabStart
  Dim AQTabEnd
  Dim AQTabTotTime
  Dim StoreToCrdStart
  Dim StoreToCrdEnd
  Dim StoreToCrdTotTime
  Dim ChkSpikeStart
  Dim ChkSpikeEnd
  Dim ChkSpikeTotTime
  Dim AddSpikeStart
  Dim AddSpikeEnd
  Dim AddSpikeTotTime
  Dim ProcessTime
  Dim DataOutCount
  Dim AQcount
  Dim Data1mCount
  Dim CardBadCount
  Dim CardOkCount
#EndIf
'---------------------------------------------------------DEBUGGING!---------------------------------------------------------

'---------VM Diagnostic Variables
'Public PowerSwitch As Boolean 'does user want to allow power to be cycled on ADCP
Public Banner As String * 200 'ADCP response from sending a break
Public Warning As String * 2000 'echo of ADCP response for anything other than a break
Public VMMemString As String * 200 'response for "get free memory" command
'Public PT3Full As String * 2000 'Response from PT3 command

#If GetNoiseFloor = Yes Then
  Public NoiseFlrParsed As String * 105 '"RSSI Noise Floor" pasrsed from PT3 Command
  Public FilterString As String * 5 'Holds string that the "InStr" instruction searches for
  Public StartString 'Holds value for where "RSSI" begins in the PT3 command string
  Public NoiseHGainW(4) 'array to hold values for each beam's "High Gain, WideBandwidth" Noise Floor
  Public NoiseLGainW(4) 'Array to hold values for each beam's "Low Gain, WideBandwidth" Noise Floor
  Public NoiseHGainN(4) 'Array to hold values for each beam's "High Gain, Narrow Bandwidth" noise floor
  Public NoiseLGainN(4) 'Array to hold calues for each beam's "Low Gain, Narrow Bandwidth" noise floor
  Public SendPT3 As Boolean
  Public PT3Time As Long
#EndIf
Public CMD As String 'user entered command for the ADCP, ex: make bin size 250cm = "ws250"
Public CSCmd As String * 10 'echo of CS (deploy command) to ensure ADCP deployed properly
Public SendCMD As Boolean 'after command is input in "CMD" user must turn this to "true" to actually send the command to ADCP
Public WakeUpVM As Boolean 'send a break/cycle power to ADCP in case it went to sleep. manual switch
Public VMRestartAttempts As Long 'how many times has the ADCP tried to restart
Public VMLowMem As Boolean 'indicator if ADCP internal  memory is below user threshold
Public VMLowMemCount As Float 'how many times ADCP internal memory is below user threshold
Public VMMemFree As Float 'how much internal memory does the ADCP have remaining
Public VMLowMemVal As Float 'user threshold for "low internal memory"
Public VMNoMem As Boolean 'flag indicating no internal memory remaining
Public VMNoMemCount As Float 'how many times has the ADCP had no internal memory remaining
Public RecErased As Boolean 'flag indicating the internal memory was erased
Public RecEraseString As String * 200 'echo of response from ADCP when internal memory is erased (also acts as indicator to trigger "RecErased" flag)

'------------------------String used to send specific data through serial communications to another logger-------------------
'Public OutString As String * 1000 'string of variables/values to be sent out to another datalogger
Public SendFlowData As Boolean 'user selectable flag to send only flow data

PreserveVariables 'preserve values in case of power outages
SetStatus ("USRDriveSize",16384)
'__________________________Define Output Tables___________________________________________
'table for startup, holds only "true" OR "false"
'DataTable (Startup,True,2)
'  Sample (1,StartPrams,String)
'EndTable

'15 MINUTE DATA OUTPUT TABLE
'data output table has no DataInterval instruction
'execution of table is controlled completely by main code logic below.
#If (WqSonde <> "NONE") Then
  DataTable (DataOut,Rec15minFlag,-1)'records data only when Record Flag = yes
    OpenInterval 'tells table to process from last execution of table
    CardOut (0,17280) 'sends copy of data to CF card
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,IndexVel,IEEE4)
    Average (1,IndexVel,IEEE4,BadVelFlag)
    Average (1,MeanVel,IEEE4,BadQFlag)
    Average (1,Qcfs,IEEE4,BadQFlag)
    Sample (1,StagePrime,IEEE4)
    Average (1,StagePrime,IEEE4,BadStgFlag)
    Sample (1,StageSecnd,FP2)
    Average (1,StageSecnd,IEEE4,false)
    Average (1,PS1Stg,IEEE4,false)
    Average (1,PS2Stg,IEEE4,false)
    Average (1,UpBeamStg,IEEE4,false)
    Average (1,VMPressStg,IEEE4,false)
    Average (1,SondeStg,IEEE4,false)
    Average (1,StgDiff,IEEE4,False)
    Sample (1,StgSelect,String)
    Average (1,VMpitch,FP2,False)
    Average (1,VMroll,FP2,False)
    Sample (1,VMHeading,FP2)
    Average (1,VMtempC,FP2,False)
    Minimum (1,CR1Volts,FP2,False,False)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,BadStgCount,FP2)
    Sample (1,BadVelCount,FP2)
    Sample (1,BadQCount,FP2)
    Average (MaxBins,VMBinVel(),IEEE4,VmBinVelDisable())
    Average(1,AvgSwathRSSI,FP2,False)
    Sample (1,LowRatVel,FP2)
    Sample (1,HighRatVel,FP2)
    Minimum (1,ExtWHConvertVolt,FP2,False,False)
    Minimum (1,ExtSolarVolt,FP2,False,False)
    Average (1,RangedBin,FP2,False)
    'WQ data
    Sample (1,WqTempC,FP2)
    Average (1,TempDiff,IEEE4,False)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqBattV,FP2)
    Sample (1,WqDOMgl,FP2)
    Sample (1,WqPH,FP2)
    Sample (1,WqTurbFNU,FP2)
    Sample (1,WqChlugL,FP2)
    Sample (1,WqChlRFU,FP2)
    Average (1,WqDepthFt,FP2,WqBadData)
    Average (1,WqTurbFNU,FP2,WqBadData)
    Median (1,WqTurbFNU,15,FP2,WqBadData)
    'Maximum (1,LastGoodBin,FP2,False,False)
    Sample (1,WqDOSat,FP2)
    Sample (1,WqORP,FP2)
    Sample (1,WqFDOMrfu,FP2)
    Sample (1,WqFDOMqsu,FP2)
    Sample (1,WqBGAugl,FP2)
    Sample (1,WqNH4mgl,FP2)
    Sample (1,WqNO3mgl,FP2)
    Sample (1,WqCLmgl,FP2)
    Sample (1,WqWiperPos,FP2)
  EndTable
#EndIf

#If (WqSonde = "NONE") Then 'Don't store non-existent WQ data in the DataOutTable
  DataTable (DataOut,Rec15minFlag,-1)'records data only when Record Flag = yes
    OpenInterval 'tells table to process from last execution of table
    CardOut (0,17280) 'sends copy of data to CF card
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,IndexVel,IEEE4)
    Average (1,IndexVel,IEEE4,BadVelFlag)
    Average (1,MeanVel,IEEE4,BadQFlag)
    Average (1,Qcfs,IEEE4,BadQFlag)
    Sample (1,StagePrime,IEEE4)
    Average (1,StagePrime,IEEE4,BadStgFlag)
    Sample (1,StageSecnd,FP2)
    Average (1,StageSecnd,IEEE4,false)
    Average (1,PS1Stg,IEEE4,false)
    Average (1,PS2Stg,IEEE4,false)
    Average (1,UpBeamStg,IEEE4,false)
    Average (1,VMPressStg,IEEE4,false)
    Average (1,SondeStg,IEEE4,false)
    Average (1,StgDiff,IEEE4,False)
    Sample (1,StgSelect,String)
    Average (1,VMpitch,FP2,False)
    Average (1,VMroll,FP2,False)
    Average (1,VMtempC,FP2,False)
    Sample (1,VMHeading,FP2)
    Minimum (1,CR1Volts,FP2,False,False)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,BadStgCount,FP2)
    Sample (1,BadVelCount,FP2)
    Sample (1,BadQCount,FP2)
    Average (MaxBins,VMBinVel(),IEEE4,VmBinVelDisable())
    Average(1,AvgSwathRSSI,FP2,False)
    'Maximum (1,LastGoodBin,FP2,False,False)
    Sample (1,LowRatVel,FP2)
    Sample (1,HighRatVel,FP2)
    Minimum (1,ExtWHConvertVolt,FP2,False,False)
    Minimum (1,ExtSolarVolt,FP2,False,False)
  EndTable
#EndIf
'Data table that is only used for obtaining an EXO burst (1 minute burst of one second dat, once every 15 minutes
#If WqSonde = "WQ_SERIAL_BURST" Then
  DataTable(Burst,RecBurstFlag,-1)
    'DataInterval(0,1,Min,-1)
    CardOut (0,17280)
    OpenInterval
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,BurstDate,IEEE4)
    Sample (1,BurstTime,IEEE4)
    Sample (1, BurstPeriod, IEEE4)
    '    Sample (1,BurstMedDate,IEEE4)
    '    Sample (1,BurstMedTime,IEEE4)
    Median (1,BurstDate,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTime,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTempC,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTempF,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstSpCond,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstTurbFNU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDOSat, MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDOmgL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstORP,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstDepthFt,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstBattV,MaxBurstCnt,FP2,BurstMissed)
    Median (1,BurstpH,MaxBurstCnt,FP2,BurstMissed)
    Median (1,BurstpHmV,MaxBurstCnt,FP2,BurstMissed)
    Median (1,BurstChlugL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstChlRFU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstBGApcRFU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstBGApcugL,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstFdomRFU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstFDomQSU,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstNH4Amgl,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstNO3Nmgl,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstCLmgl,MaxBurstCnt,IEEE4,BurstMissed)
    Median (1,BurstWiperPos,MaxBurstCnt,FP2,BurstMissed)
    StdDev (1,BurstTempC,IEEE4,False)
    Minimum (1,BurstTempC,IEEE4,False,0)
    Maximum (1,BurstTempC,IEEE4,False,0)
    StdDev (1,BurstSpCond,IEEE4,False)
    Minimum (1,BurstSpCond,IEEE4,False,0)
    Maximum (1,BurstSpCond,IEEE4,False,0)
    StdDev (1,BurstTurbFNU,IEEE4,False)
    Minimum (1,BurstTurbFNU,IEEE4,False,0)
    Maximum (1,BurstTurbFNU,IEEE4,False,0)
    StdDev (1,BurstDOSat,IEEE4,False)
    Minimum (1,BurstDOSat,IEEE4,False,0)
    Maximum (1,BurstDOSat,IEEE4,False,0)
    StdDev (1,BurstDOmgL,IEEE4,False)
    Minimum (1,BurstDOmgL,IEEE4,False,0)
    Maximum (1,BurstDOmgL,IEEE4,False,0)
    StdDev (1,BurstORP,IEEE4,False)
    Minimum (1,BurstORP,IEEE4,False,0)
    Maximum (1,BurstORP,IEEE4,False,0)
    StdDev (1,BurstDepthFt,IEEE4,False)
    Minimum (1,BurstDepthFt,IEEE4,False,0)
    Maximum (1,BurstDepthFt,IEEE4,False,0)
    StdDev (1,BurstBattV,FP2,False)
    Minimum (1,BurstBattV,FP2,False,0)
    Maximum (1,BurstBattV,FP2,False,0)
    StdDev (1,BurstpH,FP2,False)
    Minimum (1,BurstpH,FP2,False,0)
    Maximum (1,BurstpH,FP2,False,0)
    StdDev (1,BurstpHmV,FP2,False)
    Minimum (1,BurstpHmV,FP2,False,0)
    Maximum (1,BurstpHmV,FP2,False,0)
    StdDev (1,BurstChlugL,IEEE4,False)
    Minimum (1,BurstChlugL,IEEE4,False,0)
    Maximum (1,BurstChlugL,IEEE4,False,0)
    StdDev (1,BurstChlRFU,IEEE4,False)
    Minimum (1,BurstChlRFU,IEEE4,False,0)
    Maximum (1,BurstChlRFU,IEEE4,False,0)
    StdDev (1,BurstBGApcRFU,IEEE4,False)
    Minimum (1,BurstBGApcRFU,IEEE4,False,0)
    Maximum (1,BurstBGApcRFU,IEEE4,False,0)
    StdDev (1,BurstBGApcugL,IEEE4,False)
    Minimum (1,BurstBGApcugL,IEEE4,False,0)
    Maximum (1,BurstBGApcugL,IEEE4,False,0)
    StdDev (1,BurstFdomRFU,IEEE4,False)
    Minimum (1,BurstFdomRFU,IEEE4,False,0)
    Maximum (1,BurstFdomRFU,IEEE4,False,0)
    StdDev (1,BurstFDomQSU,IEEE4,False)
    Minimum (1,BurstFDomQSU,IEEE4,False,0)
    Maximum (1,BurstFDomQSU,IEEE4,False,0)
    StdDev (1,BurstNH4Amgl,IEEE4,False)
    Minimum (1,BurstNH4Amgl,IEEE4,False,0)
    Maximum (1,BurstNH4Amgl,IEEE4,False,0)
    StdDev (1,BurstNO3Nmgl,IEEE4,False)
    Minimum (1,BurstNO3Nmgl,IEEE4,False,0)
    Maximum (1,BurstNO3Nmgl,IEEE4,False,0)
    StdDev (1,BurstCLmgl,IEEE4,False)
    Minimum (1,BurstCLmgl,IEEE4,False,0)
    Maximum (1,BurstCLmgl,IEEE4,False,0)
    StdDev (1,BurstWiperPos,FP2,False)
    Minimum (1,BurstWiperPos,FP2,False,0)
    Maximum (1,BurstWiperPos,FP2,False,0)
    Sample (1,TotalBurstVals,FP2)
    Sample (1,BurstMissed,Boolean)
    Sample (1,BurstErrCnt,FP2)
  EndTable
  
'__________________________________________Metadata for each burst sample_____________________________________
'_____________________collect each 1 second value that is being used to calculate "Burst" table values________________
  DataTable(SecBurst,True,-1)
    'DataInterval(0,1,Min,-1)
    CardOut (0,350000)
    OpenInterval
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample (1,BurstDate,IEEE4)
    Sample (1,BurstTime,IEEE4)
    Sample (1,BurstTempC,IEEE4)
    Sample (1,BurstTempF,IEEE4)
    Sample (1,BurstSpCond,IEEE4)
    Sample (1,BurstTurbFNU,IEEE4)
    Sample (1,BurstDOSat,IEEE4)
    Sample (1,BurstDOmgL,IEEE4)
    Sample (1,BurstORP,IEEE4)
    Sample (1,BurstDepthFt,IEEE4)
    Sample (1,BurstBattV,FP2)
    Sample (1,BurstpH,FP2)
    Sample (1,BurstpHmV,FP2)
    Sample (1,BurstChlugL,IEEE4)
    Sample (1,BurstChlRFU,IEEE4)
    Sample (1,BurstBGApcRFU,IEEE4)
    Sample (1,BurstBGApcugL,IEEE4)
    Sample (1,BurstFdomRFU,IEEE4)
    Sample (1,BurstFDomQSU,IEEE4)
    Sample (1,BurstNH4Amgl,IEEE4)
    Sample (1,BurstNO3Nmgl,IEEE4)
    Sample (1,BurstCLmgl,IEEE4)
    Sample (1,BurstWiperPos,FP2)
    Sample (1,TotalBurstVals,FP2)
    Sample (1,jCount,FP2)
    Sample (1,BurstMissed,Boolean)
    Sample (1,BurstErrCnt,FP2)
  EndTable

  DataTable (Aquarius,Rec15minFlag,-1) 'guaruntee aquarius table populates even if burst is not complete to avoid losing stage and velocity data
    CardOut (0,17280)
    OpenInterval
    ' aquarius table for burst
    Minimum (1,CR1Volts,FP2,False,False)
    Sample (1,MedBurstDate,IEEE4)
    Sample (1,MedBurstTime,IEEE4)
    Minimum (1,WqBattV,FP2,False,False)
    Sample (1,MedTempC,IEEE4) 'the "Med..." values are pulled from the burst table via "Med... = Burst.BurstMed..."
    Sample (1,MedSpCond,IEEE4)
    Sample (1,MedTurbFNU,IEEE4)
    Sample (1,MedDOSat,IEEE4)
    Sample (1,MedDOmgL,IEEE4)
    Sample (1,MedDepthFt,IEEE4)
    Sample (1,MedBattV,FP2)
    Sample (1,MedpH,IEEE4)
    Sample (1,MedChlugL,IEEE4)
    Sample (1,MedChlRFU,IEEE4)
    Sample (1,MedFdomRFU,IEEE4)
    Sample (1,MedFDomQSU,IEEE4)
    '    Median (1,BurstTempC,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstSpCond,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstTurbFNU,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstDOSat,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstDOmgL,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstDepthFt,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstBattV,MaxBurstCnt,FP2,WqBadData)
    '    Median (1,BurstpH,MaxBurstCnt,FP2,WqBadData)
    '    Median (1,BurstChlugL,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstChlRFU,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstFdomRFU,MaxBurstCnt,IEEE4,WqBadData)
    '    Median (1,BurstFDomQSU,MaxBurstCnt,IEEE4,WqBadData)
    Sample (1,AvgPS1Stg,IEEE4)
    Sample (1,AvgPS2Stg,IEEE4)
    Sample (1,AvgUpBeamStg,IEEE4)
    '    Sample (1,AvgStagePrime,IEEE4)
    '    Sample (1,AvgStageSec,IEEE4)
    Sample (1,AvgIndexVel,IEEE4)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,AvgVMTemp,IEEE4)
    Sample (1,AvgVMPitch,IEEE4)
    Sample (1,AvgVMRoll,IEEE4)
    '    Sample (1,AvgLoggerQcfs,IEEE4)
  EndTable
#ElseIf (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SDI12") Then
  'regular aquarius table with instantaneous values
  DataTable (Aquarius,Rec15minFlag,-1)
    CardOut (0,17280)
    OpenInterval
    Minimum (1,CR1Volts,FP2,False,False)
    Sample (1,WqDate,IEEE4)
    Sample (1,WqTime,IEEE4)
    Minimum (1,WqBattV,FP2,False,False)
    Sample (1,WqTempC,IEEE4)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,IEEE4)
    Sample (1,WqDOSat,IEEE4)
    Sample (1,WqDOMgl,IEEE4)
    Sample (1,WqDepthFt,IEEE4)
    Sample (1,WqBattV,IEEE4)
    Sample (1,WqPH,IEEE4)
    Sample (1,WqChlugL,IEEE4)
    Sample (1,WqChlRFU,IEEE4)
    Sample (1,WqFDOMrfu,IEEE4)
    Sample (1,WqFDOMqsu,IEEE4)
    Sample (1,AvgPS1Stg,IEEE4)
    Sample (1,AvgPS2Stg,IEEE4)
    Sample (1,AvgUpBeamStg,IEEE4)
    '    Sample (1,AvgStagePrime,IEEE4)
    '    Sample (1,AvgStageSec,IEEE4)
    Sample (1,AvgIndexVel,IEEE4)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,AvgVMTemp,IEEE4)
    Sample (1,AvgVMPitch,IEEE4)
    Sample (1,AvgVMRoll,IEEE4)
    '    Sample (1,AvgLoggerQcfs,IEEE4)
  EndTable
#EndIf

#If (WqSonde = "NONE") Then 'Don't write non-existent WQ data to the AQ table
  DataTable (Aquarius,Rec15minFlag,-1)
    CardOut (0,17280)
    OpenInterval
    Minimum (1,CR1Volts,FP2,False,False)
    Sample (1,AvgPS1Stg,IEEE4)
    Sample (1,AvgPS2Stg,IEEE4)
    Sample (1,AvgUpBeamStg,IEEE4)
    '    Sample (1,AvgStagePrime,IEEE4)
    '    Sample (1,AvgStageSec,IEEE4)
    Sample (1,AvgIndexVel,IEEE4)
    Minimum (1,VMVolts,FP2,False,False)
    Sample (1,AvgVMTemp,IEEE4)
    Sample (1,AvgVMPitch,IEEE4)
    Sample (1,AvgVMRoll,IEEE4)
    '    Sample (1,AvgLoggerQcfs,IEEE4)
  EndTable
#EndIf

'Store Velocity  data for all bins (used for beam coordinate studies)
#If IsSpecStudy = Yes Then
  DataTable (VelData,RecAllVelFlag,-1)
    OpenInterval 'tells table to process from last execution of table
    CardOut (0,17280) 'sends copy of data to CF card, maybe output this table...
    Sample (1,SiteID,String)
    Sample (1,SiteNum,String)
    Sample(1,Coord,String)
    Sample(1,Decode,String)
    Average(MaxBins,V1(),FP2,V1Disable())
    Average(MaxBins,V2(),FP2,V2Disable())
    Average(MaxBins,V3(),FP2,V3Disable())
    Average(MaxBins,V4(),FP2,V4disable())
    Average (108,ensRSSI(),UINT2,False)
    Average (108,ensCorr(),UINT2,False)
    Sample (1,VMHeading,FP2)
    Average (1,VMpitch,FP2,False)
    Average (1,VMroll,FP2,False)
    Average (1,VMtempC,FP2,False)
    'store other... x, y, think about this... what do we really want in here
  EndTable
#EndIf

'BadQCount or YsiErrCount = 200 (problem for more than 3 hours)
'And it is called at Midnight
'QAQC table that is called at midnight and gets pertainent information
'DataTable  (QAQCInfo,Rec24HrFlag,-1)
'  CardOut (0,180) 'sends copy of data to CF card (Will store a lot of data on card)
'  'TableFile("USR:Test",8,2,0,24,Hr,Outstat,LastFileName) 'when OutStat = True, then data goes to FTP site
'  'Store system info here
'  Sample (1,SiteID,String)
'  Sample (1,SiteNum,String)
'  Sample (1,Tech,String)
'  Sample (1,VisitReason,String
'  Sample (1,Program,String)
'  Sample (1,ProgVersDate,String)
'  Sample (1,SerNum,Long)
'  Sample (1,OSVers,String)
'  Sample (1,AdcpSN,Long)
'  Sample (1,IsCM,Boolean)
'  Sample (1,NewADCP,Boolean)
'  Sample (1,PS1SN,String)
'  Sample (1,NewPS1,Boolean)
'  Sample (1,PS2SN,String)
'  Sample (1,NewPS2,Boolean)
'  Sample (1,EX,Long)'how is the vm setup
'  Sample (1,Coord,String)
'  Sample (1,Decode,String)
'  Sample (1,ProgErrors,Long)
'  Sample (1,Low12Volts,Long)
'  Sample (1,LithBat,FP2)
'  Sample (1,SkipScans,Long)
'  Sample (1,FreeCFMem,IEEE4)
'  Sample (1,LowMeas,Boolean)
'  Sample (1,HighMeas, Boolean)
'  Sample (1,BadQCount,Long)
'  Sample (1,BadVelCount,Long)
'  Sample (1,BadBinCnt,Long)
'  Sample (1,BadEnsCount,FP2)
'  Sample (1,BadStgCount,Long)
'  #If (WqSonde <> "NONE") Then
'    Sample (1,WqErrCount,Long)
'    Sample (1,WqBattV,FP2)
'  #EndIf
'  Sample (1,VMRestartAttempts,FP2)
'  Sample (1,IndexVel,FP2)
'  Sample (1,StagePrime,IEEE4)
'  Sample (1,StageSecnd,IEEE4)
'  Sample (1,SelStgPrime,FP2)
'  Sample (1,SelStgSecnd,FP2)
'  Sample (1,UpBeamStg,IEEE4)
'  Sample (1,VMPressStg,IEEE4)
'  Sample (1,PS1Stg,IEEE4)
'  Sample (1,PS2Stg,IEEE4)
'  Sample (1,SondeStg,IEEE4)
'  Sample (1,UpBeamOffset,IEEE4)
'  Sample (1,VMPressOffset,IEEE4)
'  Sample (1,PS1Offset,IEEE4)
'  Sample (1,PS2Offset,IEEE4)
'  Sample (1,SondeOffset,IEEE4)
'  Sample (1,VMtempC,FP2)
'  Sample (1,VMpitch,FP2)
'  Sample (1,VMroll,FP2)
'  Sample (1,CR1Volts,FP2)
'  Sample (1,ExtWHConvertVolt,FP2)
'  Maximum (1,PTempC,FP2,false,false)
'  Minimum (1,PTempC,FP2,false,false)
'  Sample (1,NumADCPBins,FP2)
'  Sample (1,NumBeams,FP2)
'  Sample (1,EnsPings,FP2)
'  Sample (1,BinSize,FP2)
'  Sample (1,BlankDist,FP2)
'  Sample (1,StartBin,FP2)
'  Sample (1,EndBin,FP2)
'  Sample (1,StartEbbBin,FP2)
'  Sample (1,EndEbbBin,FP2)
'  Sample (1,StartFldBin,FP2)
'  Sample (1,EndFldBin,FP2)
'  Sample (1,BiRatTran,FP2)
'  Sample (1,UseBiRat,Boolean)
'  Sample (1,CutOffBins,FP2)
'  Sample (1,VMHeading,FP2)
'  Sample (1,UseV2,Boolean)
'  Sample (1,FlowSign,Long)
'  Sample (1,CdmaWorks,Boolean)
'  'Maximum (1,LastGoodBin,FP2,False,False)
'  'Minimum (1,LastGoodBin,FP2,False,False)
'  'Average (1,LastGoodBin,FP2,False)
'  Sample (1,StgOffset,IEEE4)
'  Sample (1,StgCoef,IEEE4)
'  Sample (1,StgCoef2,IEEE4)
'  Sample (1,VelOffset,IEEE4)
'  Sample (1,VelCoef,IEEE4)
'  Sample (1,VelCoef2,IEEE4)
'  Sample (1,VelCoef3,IEEE4)
'  Sample (1,UpVelOffset,IEEE4)
'  Sample (1,UpVelCoef,IEEE4)
'  Sample (1,UpVelCoef2,IEEE4)
'  Sample (1,UpVelCoef3,IEEE4)
'  Sample (1,LowVelOffset,IEEE4)
'  Sample (1,LowVelCoef,IEEE4)
'  Sample (1,LowVelCoef2,IEEE4)
'  Sample (1,LowVelCoef3,IEEE4)
'  Sample (1,Trans,FP2)
'  Sample (1,VMLowMemCount,FP2)
'  Sample (1,VMLowMem,Boolean)
'  Sample (1,VMMemFree,FP2)
'  Sample (1,RecErased,Boolean)
'EndTable

'This data table is called when there is a station visit
'DataTable(SiteVisit,True,-1)
'  CardOut (0,50)
'  Sample (1,SiteID,String)
'  Sample (1,SiteNum,String)
'  Sample (1,IndexVel,IEEE4)
'  Sample (1,Qcfs,IEEE4)
'  Sample (1,StagePrime,IEEE4)
'  Sample (1,UpBeamStg,IEEE4)
'  Sample (1,VMPressStg,IEEE4)
'  Sample (1,PS1Stg,IEEE4)
'  Sample (1,PS2Stg,IEEE4)
'  Sample (1,SondeStg,IEEE4)
'  Sample (1,UpBeamOffset,IEEE4)
'  Sample (1,VMPressOffset,IEEE4)
'  Sample (1,PS1Offset,IEEE4)
'  Sample (1,PS2Offset,IEEE4)
'  Sample (1,SondeOffset,IEEE4)
'  Sample (1,VMtempC,FP2)
'  Sample (1,VMpitch,FP2)
'  Sample (1,VMroll,FP2)
'  Sample (1,CR1Volts,FP2)
'  Sample (1,ExtWHConvertVolt,FP2)
'  Sample (1,StartBin,Long)
'  Sample (1,EndBin,Long)
'  Sample (1,VMHeading,FP2)
'  Sample (1,NumADCPBins,Long)
'  Sample (1,BlankDist,Long)
'  Sample (1,BinSize,Long)
'  Sample (1,CutOffBins,FP2)
'  #If (WqSonde <> "NONE") Then
'    Sample (1,WqBattV,FP2)
'    Sample (1,WqTempC,FP2)
'    Sample (1,WqSpCond,IEEE4)
'    Sample (1,WqTurbFNU,FP2)
'    Sample (1,WqDOMgl,FP2)
'    Sample (1,WqPH,FP2)
'    Sample (1,WqChlugL,FP2)
'    Sample (1,WqChlRFU,FP2)
'    Sample (1,WqDepthFt,FP2)
'    Sample (1,WqDOSat,FP2)
'    Sample (1,WqFDOMrfu,FP2)
'    Sample (1,WqFDOMqsu,FP2)
'    Sample (1,WqBGArfu,FP2)
'    Sample (1,WqBGAugl,FP2)
'    Sample (1,WqNH4mgl,FP2)
'    Sample (1,WqNO3mgl,FP2)
'    Sample (1,WqCLmgl,FP2)
'    Sample (1,WqErrCount,Long)
'  #EndIf
'  Sample (1,BadQCount,Long)
'  Sample (1,LithBat,FP2)
'  Sample (1,Tech,String)
'  Sample (1,VisitReason,String)
'  Sample (1,VMMemFree,FP2)
'EndTable

'1 MINUTE DATA OUTPUT TABLE
DataTable (Data1m,Rec1MinFlag,-1)
  OpenInterval
  CardOut (0,43200)
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,StagePrime,IEEE4)
  Sample (1,IndexVel,IEEE4)
  Sample (1,MeanVel,IEEE4,)
  Sample (1,Qcfs,IEEE4)
  #If (WqSonde <> "NONE") Then
    Sample (1,WqBattV,FP2)
    Sample (1,WqTempC,FP2)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,FP2)
    Sample (1,WqDOMgl,FP2)
    Sample (1,WqPH,FP2)
    Sample (1,WqPHmv,FP2)
    Sample (1,WqChlugL,FP2)
    Sample (1,WqChlRFU,FP2)
    Sample (1,WqDepthFt,FP2)
    Sample (1,WqDOSat,FP2)
    Sample (1,WqFDOMrfu,FP2)
    Sample (1,WqFDOMqsu,FP2)
    Sample (1,WqBGArfu,FP2)
    Sample (1,WqBGAugl,FP2)
    Sample (1,WqNH4mgl,FP2)
    Sample (1,WqNO3mgl,FP2)
    Sample (1,WqCLmgl,FP2)
    Sample (1,WqWiperPos,FP2)
  #EndIf
  Sample (MaxBins,VMBinVel(),IEEE4)
  Sample (MaxBins,V1(),IEEE4)
  Sample (MaxBins,V2(),IEEE4)
  Sample (MaxBins,V3(),IEEE4)
  Sample (MaxBins,V4(),IEEE4)
  Sample (1,RangedBin,FP2)
  Sample (1,CutOffBins,FP2)
  Sample (1,LowRatVel,FP2)
  Sample (1,HighRatVel,FP2)
  Sample (1,SelStgPrime,FP2)
  Sample (1,StageSecnd,IEEE4)
  Sample (1,SelStgSecnd,FP2)
EndTable

'BEAMCHECK DATA OUTPUT TABLE
'DataTable (BeamCheck,RecBeamCheckFlag,-1)
'  OpenInterval
'  CardOut (0,17280)
'  Sample (1,SiteID,String)
'  Sample (1,StagePrime,IEEE4)
'  Sample (1,NumBeams,Long)
'  Sample (1,NumADCPBins,Long)
'  Sample (1,BinSize,Long)
'  Sample (1,StartBin,Long)
'  Sample (1,EndBin,Long)
'  Sample (1,VMpitch,FP2)
'  Sample (1,VMroll,FP2)
'  Average (108,ensRSSI(),UINT2,False)
'  Average (108,ensCorr(),UINT2,False)
'  Sample (1,VMupBeam,IEEE4)
'  Average (1,VMupBeam,IEEE4,False)
'  Sample (1,VMtempC,IEEE4)
'  Average (1,VMtempC,IEEE4,False)
'  Sample (1,VMVolts,IEEE4)
'  Average (1,VMVolts,IEEE4,False)
'  Sample (1,ExtWHConvertVolt,IEEE4)
'  Average (1,ExtWHConvertVolt,IEEE4,False)
'EndTable

'___________Field Readings Table____________
'This table will only store a single record.
'Techs can access it for field readings in SVMaq rather than scrolling through the Public Table
DataTable (SVMaq,True,1)
  Sample (1,SiteID,String)
  Sample (1,SiteNum,String)
  Sample (1,CR1Volts,FP2)
  #If HasVM <> False Then
    Sample (1,StagePrime,FP2)
    Sample (1,StageSecnd,FP2)
    Sample (1,PS1Stg,FP2)
    Sample (1,PS2Stg,IEEE4)
    Sample (1,UpBeamStg,IEEE4)
    Sample (1,VMPressStg,IEEE4)
    Sample (1,SondeStg,IEEE4)
    Sample (1,IndexVel,FP2)
    Sample (1,VMpitch,FP2)
    Sample (1,VMroll,FP2)
    Sample (1,VMtempC,FP2)
    Sample (1,VMVolts,FP2)
    Sample (1,PS1Offset,IEEE4)
    Sample (1,PS2Offset,IEEE4)
    Sample (1,UpBeamOffset,IEEE4)
    Sample (1,VMPressOffset,IEEE4)
    Sample (1,SondeOffset,IEEE4)
  #EndIf
  #If (WqSonde <> "NONE") Then
    Sample (1,WqBattV,FP2)
    Sample (1,WqTempC,FP2)
    Sample (1,WqSpCond,IEEE4)
    Sample (1,WqTurbFNU,FP2)
    Sample (1,WqDOMgl,FP2)
    Sample (1,WqPH,FP2)
    Sample (1,WqPHmv,FP2)
    Sample (1,WqChlugL,FP2)
    Sample (1,WqChlRFU,FP2)
    Sample (1,WqDepthFt,FP2)
    Sample (1,WqDOSat,FP2)
    Sample (1,WqFDOMrfu,FP2)
    Sample (1,WqFDOMqsu,FP2)
    Sample (1,WqBGArfu,FP2)
    Sample (1,WqBGAugl,FP2)
    Sample (1,WqNH4mgl,FP2)
    Sample (1,WqNO3mgl,FP2)
    Sample (1,WqCLmgl,FP2)
    Sample (1,WqWiperPos,FP2)
  #EndIf
EndTable

'NOISE FLOOR DATA TABLE
'#If GetNoiseFloor = Yes Then
'  DataTable (NoiseFloor,True,-1)
'    OpenInterval
'    CardOut (0,180)
'    Sample (1,SiteID,String)
'    Sample (1,SiteNum,String)
'    Sample (4,NoiseHGainW(),FP2)
'    'Sample (1,NoiseHGainW(2),FP2)
'    Sample (4,NoiseHGainN(),FP2)
'    'Sample (1,NoiseHGainN(2),FP2)
'    Sample (4,NoiseLGainW(),FP2)
'    'Sample (1,NoiseLGainW(2),FP2)
'    Sample (4,NoiseLGainN(),FP2)
'    'Sample (1,NoiseLGainN(2),FP2)
'    Sample (1,VMtempC,IEEE4)
'    Sample (1,VMVolts,IEEE4)
'    Sample (1,ExtWHConvertVolt,IEEE4)
'  EndTable
'#EndIf

DataTable (Debugger,True,-1)
  OpenInterval
  CardOut (0,1440)
  Sample (1,ScanStart,FP2)
  Sample (1,ScanEnd,FP2)
  Sample (1,ADCPEnd,FP2)
  Sample (1,BeforeBurst,FP2)
  Sample (1,AfterBurst,FP2)
  #If (WqSonde <> "NONE") Then
    #If (WqSonde = "WQ_SERIAL_BURST") Then
      Sample (1,BurstDebugCount,FP2)
      Sample (1,BurstCount,FP2)
      Sample (1,WipeTime,String)
      Sample (1,WqDelay,FP2)
      Sample (1,Wipeflag,Boolean)
    #EndIf
    Sample (1,WqErrCount,FP2)
    Sample (1,WqPwrCycleCnt,Long)
  #EndIf
  Sample (1,CDMACheckStart,FP2)
  Sample (1,CDMACheckEnd,FP2)
  Sample (1,CDMACheckTotTime,FP2)
  Sample (1,ZeroVMTimeStart,FP2)
  Sample (1,ZeroVMTimeEnd,FP2)
  Sample (1,ZeroVMTotTime,FP2)
  Sample (1,ChkSumChkStart,FP2)
  Sample (1,ChkSumChkEnd,FP2)
  Sample (1,ChkSumChkTotTime,FP2)
  Sample (1,MainDecodeStart,FP2)
  Sample (1,MainDecodeEnd,FP2)
  Sample (1,MainDecodeTotTime,FP2)
  Sample (1,CalcRangeStart,FP2)
  Sample (1,CalcRangeEnd,FP2)
  Sample (1,CalcRangeTotTime,FP2)
  Sample (1,OneMinCalcStart,FP2)
  Sample (1,OneMinCalcEnd,FP2)
  Sample (1,OneMinCalcTotTime,FP2)
  Sample (1,CalcQStart,FP2)
  Sample (1,CalcQEnd,FP2)
  Sample (1,CalcQTotTime,FP2)
  Sample (1,GetVMMemStart,FP2)
  Sample (1,GetVMMemEnd,FP2)
  Sample (1,GetVMMemTotTime,FP2)
  Sample (1,VMTimeStart,FP2)
  Sample (1,VMTimeEnd,FP2)
  Sample (1,VMTotTime,FP2)
  Sample (1,CallBmChkStart,FP2)
  Sample (1,CallBmChkEnd,FP2)
  Sample (1,CallBmChkTotTime,FP2)
  Sample (1,DataTabsStart,FP2)
  Sample (1,DataTabsEnd,FP2)
  Sample (1,DataTabsTotTime,FP2)
  Sample (1,DataOutStart,FP2)
  Sample (1,DataOutEnd,FP2)
  Sample (1,DataOutTotTime,FP2)
  Sample (1,Data1mStart,FP2)
  Sample (1,Data1mEnd,FP2)
  Sample (1,Data1mTotTime,FP2)
  Sample (1,AQTabStart,FP2)
  Sample (1,AQTabEnd,FP2)
  Sample (1,AQTabTotTime,FP2)
  Sample (1,StoreToCrdStart,FP2)
  Sample (1,StoreToCrdEnd,FP2)
  Sample (1,StoreToCrdTotTime,FP2)
  Sample (1,ChkSpikeStart,FP2)
  Sample (1,ChkSpikeEnd,FP2)
  Sample (1,ChkSpikeTotTime,FP2)
  Sample (1,AddSpikeStart,FP2)
  Sample (1,AddSpikeEnd,FP2)
  Sample (1,AddSpikeTotTime,FP2)
  Sample (1,ProcessTime,FP2)
  Sample (1,DataOutCount,FP2)
  Sample (1,Data1mCount,FP2)
  Sample (1,AQcount,FP2)
  Sample (1,CardBadCount,FP2)
  Sample (1,CardOkCount,FP2)
  Sample (1,OneMinCount,FP2)
  #If WqSonde <> "WQ_SDI12" AND WqSonde <> "NONE" Then
  Sample (1,BurstComs,String)
  #EndIf
EndTable

DataTable (DebugTimer,True,2880)
  Sample (9,DebugTime(),IEEE4)
EndTable
'____________________________________SUBROUTINES__________________________________________

'________________________________Get Startup Information__________________________________
Sub GetStartup
  'look at startup table to see if user set UseDefaults to no
  '  If Startup.StartPrams(1,1) <> "false" Then 'insert default values
  '    UseDefaults = "false"
  ProgVersDate = ProgramVersionDate
  LastScan = "00:00"
  '******************Below are the default stations Parameters (~ line 740) *********************
  Tech = "TEC"
  SiteID = "xxx"
  SiteNum = "12345678"
  VisitReason = "Program update"
  'Default Flow setup values
  'Note if using bi-rating start and end must include all EBB and FLOOD bins
  StartBin = 1
  EndBin = 27
  StartEbbBin = 1 'used for bi-directional rating
  EndEbbBin = 27 'used for bi-directional rating
  StartFldBin = 1 'used for bi-directional rating
  EndFldBin = 27  'used for bi-directional rating
  BiRating = False 'set to true if using bi-directional rating
  BiRatTran = 0 'set to transition velocity for bi-directional rating
  MinExpStg = 0
  MaxExpStg = 30
  MinExpVel = -5
  MaxExpVel = 6
  LowRatVel = 0
  HighRatVel = 0
  FlowSign = 1
  SelStgPrime = PSpress
  SelStgSecnd = UPbeam
  UpBeamOffset = 0
  VMPressOffset = 0
  PS1Offset = 0
  PS2Offset = 0
  SondeOffset = 0
  'default communication setup
  PSPressPort = 3
  PSPressAddr = 0
  PSpress2Port = 5
  PSpress2Addr = 0
  #If WqSonde = "WQ_SDI12" Then
    WqSDIPort = 5
    WqAddr = 4
    'default Ysi Sonde setup values
    LocTempC = 3
    LocSpCond = 4
    LocTurbFNU = 5
    LocVolts = 9
    LocChlorMGL = 11
    LocChlorRFU = 12
    LocPH = 10
    LocDOmgL = 7
    LocDOSat = 6
    LocDepth = 8
    LocORP = 0
    LocBGA = 0
    LocFdomRFU = 0
    LocFdomQSU = 0
    LocAmmonium = 0
    LocNitrate = 0
    LocChloride = 0
    MilliToMicro = No
  #EndIf
  'Default rating variables
  CalcQ = Yes 'change to yes if Q calculations are needed
  'Area Rating:
  StgOffset = 0
  StgCoef = 0
  StgCoef2 = 0
  'meanvel rating:
  VelOffset = 0
  VelCoef = 0
  VelCoef2 = 0
  VelCoef3 = 0
  UpVelOffset = 0
  UpVelCoef = 0
  UpVelCoef2 = 0
  UpVelCoef3 = 0
  LowVelOffset = 0
  LowVelCoef = 0
  LowVelCoef2 = 0
  LowVelCoef3 = 0
  Trans = NAN
  'Misc settings
  AvgRSSIStartBin = StartBin
  AvgRSSIEndBin  = EndBin
  '****************Above are the default stations Parameters************************
  'initialize other important program variables (typically don't need to be changed)
  BiRatOK  = False 'Used by program to determin if BiRating can be done (if using CM with Instrument Coords). do not change manually, SET TO FALSE HERE
  UseBiRat = False 'flag set BY PROGRAM if both the above are true.  do not change manually, SET TO FALSE HERE
  #If GetNoiseFloor = Yes Then
    SendPT3 = True
    PT3Time = 3
  #EndIf
  InitialHRV = HighRatVel
  InitialLRV = LowRatVel
  InitialAdcpSN = 0
  InitialPS1SN = 0
  InitialPS2SN = 0
  #If WqSonde <> "NONE" Then
    WqDead = No
    'WqDeadCnt = 0
    WqErrCount = 0
    IsWQNClosed = Yes 'Default setting is for the existance of a normally closed Sonde power relay
    #If WqSonde = "WQ_SERIAL" Then
      Redeploy = True
      RecBurstFlag = False
    #EndIf
  #EndIf
  'IF this is an uplooker calculating range based on water depth
  RangeSource = UPbeam 'sensor to use for water depth over VM transducer faces
  DucerDepthOffset = 0 'difference between water depth sensor and VM transducer face
  RangedBin = 0 'starting point for range calculation
  CutOffBins = 1 'Starting point for number of bins to discard when using AutoRange feature
  VMPower = Yes
  IsSubmersed = False
  IsCDMANClosed = Yes 'Default setting is for the existance of a normally closed cdma power relay
  isVMNClosed = Yes 'Default setting for the existance of a normally Closed VM power Relay
  KeepCDMAon = Yes 'CDMA is initially setup to stay on
  'UseAutoLastBin = No
  UseV2 = No
  UseDir = No
  IsCM = Yes
  IsVADCP = No
  PosFlowDir = 0
  TrueUpBeamStg = BadDataIndicator
  TrueVMPressStg = BadDataIndicator
  TruePS1Stg = BadDataIndicator
  TruePS2Stg = BadDataIndicator
  TrueSondeStg = BadDataIndicator
  RSSIThreshold = 8
  CorrThreshold = 15
  SelectFilter = 1
  HrsCdmaOff = 4
  CDMAFailure = No
  VemcoRTR = No
  SendFlowData = False
  'since the first time the data tables are called there is no data, then
  'initially set all the bad data flags to true so no processing occurs
  'Set ODD store data flags to no
  Rec1MinFlag = No
  OneMinCount = 0
  RecordAll = No
  RecDataFlag = False
  BadStgFlag = Yes
  BadVelFlag = Yes
  BadQFlag = Yes
  LowCount = 0 'counter for # of times Ivel is below rating
  HighCount = 0 'counter for # of times Ivel is above rating
  LowMeas = No 'below rating flag
  HighMeas = No 'above rating flag
  VMLowMemVal = 0
  #If GetNoiseFloor = Yes Then
    FilterString = "RSSI"
  #EndIf
  If IsSubmersed = False AND IsCDMANClosed Then
    #If LoggerType = CR1000 Then
      SW12(0) 'turn on telemetery if there is a Normally closed relay present.
    #EndIf
    #If LoggerType = CR6 Then
      SW12(1,0)
    #EndIf
  Else
    #If LoggerType = CR1000 Then
      SW12(1) 'turn on telemetery if there's no NC relay present
    #EndIf
    #If LoggerType = CR6 Then
      SW12(1,1)
    #EndIf
  EndIf
  IsCDMAOn = Yes
EndSub



'___________________External Battery Voltage_______________________________
Sub ExtPwrSource
  'Datalogger can only read in 5 volts or less
  'To be used with 10:1 DC voltage divider module from Campbell
  'Module divides input voltage by 10 converting to mv(13 volts results in 1300mv (1.3v))
  'Then multiplies by a number (.01) to bring at back to volts again
  VoltDiff (ExtWHConvertVolt,1,mV5000,ExtPwrCom,True,0,250,0.01,0)
  VoltDiff (ExtSolarVolt,1,mv5000,ExtSolarCom,true,0,250,0.01,0)
End Sub

'____________________________________LastScan Subroutine__________________________________
'now lets create the LastScan variable for keypad menu
'Stores current hour and minute in the LastScan Variable
Sub GetLastScan
  RealTime (rTime()) 'get real time array
  If Minute >= 0 AND Minute < 10 Then
    LastScan = Hour + ":0" + Minute
  Else
    LastScan = Hour + ":" + Minute
  EndIf
EndSub

'_______________________________ Initialize variables ___________________________________________________
Sub Initialize
  VMdataIn = No
  ScanNo = 0
  BadChecksum = 0
  HeaderMismatch = 0
  NumbytesZero = 0
  ReceivedBytes = 0
  WakeUpVM = No
  SetVMTimeFlg = No
  StoreVariablesFlg = No
  GetVariablesFlg = True
  VMRestartAttempts = 0
  AvgRSSIcounter = 0
  AvgRSSIAccum = 0
  AvgSwathRSSI = 0
  #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST")
    #If WqSonde = "WQ_SERIAL_BURST" Then
      Public iCount As Long = 0
      ResetTable(burst)
      RecBurstFlag = False
      GetBurst = Yes
    #Else
      GetBurst = No
    #EndIf
    SetEXOTimeFlg = No
    Redeploy = True
    WqParamOrder = BadDataIndicator
    Wipeflag = False
    WqManualCycle = False
    OldEXOTime = 0
  #EndIf

  'An array of longs is needed to collect the data because the campbell cannot read the
  'binary PD0 ensemble into a string.  When it hits a blank (HEX 00) it terminates the
  'string cutting off the rest of the ensemble'
  'so to get around this, we read in the data (one byte at a time) and put it into an
  'array of longs.  But at this point there is another problem. RDI transmits binary
  'data in "little indian" fashon (least significant byte first), but longs (two bytes)
  'are stored by campbell "big indian" (most significant byte first), so after we read
  'the byte in (to a temporary long),it is in the most significant byte.  We then must use the
  'MoveBytes statement to move it into the least significant position and store it in
  'the long array.
  Erase(Longarray())
  'Public TempDiff As Float
  'initialize the Universal WQ variables
  #If (WqSonde <> "NONE") Then
    WqDate = ""
    WqTime =""
    'Public WqNparams As Long
    WqTempC = 0
    WqTempF = 0
    WqSpCond = 0
    WqTurbFNU = 0
    WqChlugL = 0
    WqChlRFU = 0
    WqDOMgl = 0
    WqDOSat = 0
    WqPH = 0
    WqPHmv = 0
    WqORP = 0
    WqDepthFt = 0
    WqBattV = 0
    WqBGAugl = 0
    WqBGArfu = 0
    WqFDOMrfu = 0
    WqFDOMqsu = 0
    WqNH4mgl = 0
    WqNO3mgl = 0
    WqCLmgl = 0
    WqWiperPos = 0
    WqErrCount = 0
    WqPwrCycleCnt = 0
    WqError = False
    WqDead = False
    'WqDeadCnt = 0
  #EndIf
End Sub

'______________________________Get System Information_____________________________________
Sub GetSysInfo
  Battery (CR1Volts) 'get battery volts
  SerNum = Status.SerialNumber(1,1)
  OSVers = Status.OSVersion(1,1)
  Program = Status.ProgName(1,1)
  ProgErrors = Status.ProgErrors(1,1)
  Low12Volts = Status.Low12VCount(1,1)
  LithBat = Status.LithiumBattery(1,1)
  SkipScans = Status.SkippedScan(1,1)
  FreeCFMem = Status.CardBytesFree(1,1)
EndSub

'__________________________________CDMA Check Subroutine__________________________________
Sub CdmaCheck
  If IsSubmersed = True  Then
    ExitSub
  EndIf
  Select Case IsCDMANClosed
  Case Yes'if relay exists
    If KeepCDMAon = Yes Then 'if want CDMA on
      #If LoggerType = CR1000 Then
        SW12(0)
      #EndIf'turn on CDMA
      #If LoggerType = CR6 Then
        SW12(1,0)
      #EndIf
      IsCDMAOn = Yes
    Else 'If want CDMA off except for window
      If TimeIntoInterval(0,60,min) Then
        #If LoggerType = CR1000 Then
          SW12(0)
        #EndIf'turn on CDMA
        #If LoggerType = CR6 Then
          SW12(1,0)
        #EndIf
        IsCDMAOn = Yes
      EndIf
      If TimeIntoInterval(10,60,min) Then
        #If LoggerType = CR1000 Then
          SW12(1)
        #EndIf'turn off CDMA
        #If LoggerType = CR6 Then
          SW12(1,1)
        #EndIf
        IsCDMAOn = No
      EndIf
    EndIf
  Case No 'if relay does not exist
    If KeepCDMAon = Yes Then 'want CDMA to stay on
      #If LoggerType = CR1000 Then
        SW12(1)
      #EndIf 'turn on CDMA
      #If LoggerType = CR6 Then
        SW12(1,1)
      #EndIf
      IsCDMAOn = Yes
    Else 'want CDMA to turn off except for window
      If TimeIntoInterval(0,60,min) Then
        #If LoggerType = CR1000 Then
          SW12(1)
        #EndIf'turn on CDMA
        #If LoggerType = CR6 Then
          SW12(1,1)
        #EndIf
        IsCDMAOn = Yes
      EndIf
      If TimeIntoInterval(10,60,min) Then
        #If LoggerType = CR1000 Then
          SW12(0)
        #EndIf'turn off CDMA
        #If LoggerType = CR6 Then
          SW12(1,0)
        #EndIf
        IsCDMAOn = No
      EndIf
    EndIf
  EndSelect
  If CycleCdmaPwr = Yes Then
    If IsCDMANClosed Then
      #If LoggerType = CR1000 Then
        SW12(1)
      #EndIf'turn off telemetery if a normally closed relay is present
      #If LoggerType = CR6 Then
        SW12(1,1)
      #EndIf
    Else
      #If LoggerType = CR1000 Then
        SW12(0)
      #EndIf 'turn off telemetery if NC relay is not present
      #If LoggerType = CR6 Then
        SW12(1,0)
      #EndIf
    EndIf  'manual cycle power Open the circuit to the CDMA
    IsCDMAOn = No
    CycleCdmaPwr = No
  EndIf
  LoggernetAddr = Route(4094)
  If LoggernetAddr = 4094 Then
    CdmaWorks = Yes
    CdmaScans = 0
    CDMAFailure = No
  Else 'cycle power to CDMA
    CdmaWorks = No
    CdmaScans = CdmaScans + 1
    If (CdmaScans >= HrsCdmaOff * (FastLoopInterval * 4)) AND (EventCDMAFlag = No) Then 'Fastloop interval is no of Subscans per 15 min so * 4 is scans per hour
      If IsCDMANClosed Then
        #If LoggerType = CR1000 Then
          SW12(1)
        #EndIf'turn off telemetery if a normally closed relay is present
        #If LoggerType = CR6 Then
          SW12(1,1)
        #EndIf
      Else
        #If LoggerType = CR1000 Then
          SW12(0)
        #EndIf 'turn off telemetery if NC relay is not present
        #If LoggerType = CR6 Then
          SW12(1,0)
        #EndIf
      EndIf  'cycle cdma off after 4 hours (Open the Circuit to the CDMA)
      IsCDMAOn = No
      CDMAFailure = Yes
      CdmaScans = 0
    EndIf
  EndIf
EndSub
'
'______________________Serial Out___________________________
'This is used to send particular values out through SlaveCom. The second CR1000
'will collect these values and parse them to be used in the appropriate locations (7 variables
#If HasSlave = Yes Then
  Sub SerialDataOut
    Dim Outstring As String * 100
    Outstring = Qcfs+","+IndexVel+","+StagePrime+","+VMtempF+","+VMVolts+","+CR1Volts+","+PTempF  ' creates a variable For the String being sent out To Second datalogger
    SerialOut (SlaveCom,Outstring,"",0,0)
  EndSub
#EndIf

'---------------------Send a command to the ADCP -- Check Responses
'This subroutine is primarily used for 'expert' operators to issue command changes to the ADCP.  As written, only one command at a time can be issued from the
'user interface.  The ADCP echos and responsed are viewed from the "banner", "warning" and "CS" response variables. This capability is not available from the
'keypad, and can only be used from loggernet! Because of CR1000 limitations, the ADCP must have it's power cycled to simulate the RDI "Break" signal!
Sub (SendSetup)
  If (SendCMD) Then
    Banner = ""
    Warning = ""
    CSCmd = ""
    If CMD = "" Then
      SendCMD = False
      ExitSub
    EndIf
    SerialFlush (AdcpPort)
    'Turn Power on and off to ADCP
    Call CycleVMPower
    Call OpenADCPPort
    ''SerialOut (COMRS232,"+++","",0,100)'send alt break command
    Delay (1,1,Sec)'wait for reply
    SerialIn (Banner,AdcpPort,500,">",200)'get banner from ADCP
    'SerialIn (Prompt,AdcpPort,100,13,100)'ge
    SerialFlush (AdcpPort)
    ''send commands to HADCP
    Delay (1,1,Sec)'wait for reply
    'send a command
    SerialOut (AdcpPort,"+++" + CHR(13) + CHR(10),"",0,100)'Send
    SerialIn (Banner,AdcpPort,500,">",200)'get banner from ADCP
    SerialIn (Prompt,AdcpPort,100,-1,100)
    SerialFlush (AdcpPort)
    Delay (1,500,mSec)'wait for reply
    SerialOut (AdcpPort,CMD + CHR(13) + CHR(10),"",0,100)'Send
    SerialIn (Warning,AdcpPort,150,-1,2000)'Get Warning (if any) from ADCP
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,"CS" + CHR(13) + CHR(10),"",0,100)'CS command to start pinging
    SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
    SerialFlush (AdcpPort)
    SendCMD = False
    Call EraseWH
    #If GetNoiseFloor = Yes Then
      Call ParsePT3
    #EndIf
  EndIf
EndSub
'Open ADCP port
'----------------------------------------------
Sub OpenADCPPort
  #If LoggerType = CR6 Then
    If (IsVmMax232 = Yes) AND (AdcpPort <> ComMe) Then
      If UseCommsZeroForADCP Then
        SerialOpen (AdcpPort,VmBaud,19,0,2000,0)'open ADCP PORT with 2000 byte buffer using format 19
      Else
        SerialOpen (AdcpPort,VmBaud,19,0,2000)
      EndIf
    Else
      If UseCommsZeroForADCP Then
        SerialOpen (AdcpPort,VmBaud,3,0,2000,0)'open ADCP PORT with 2000 byte buffer using format 3
      Else
        SerialOpen (AdcpPort,VmBaud,3,0,2000)
      EndIf
    EndIf
  #Else
    If (IsVmMax232 = Yes) AND (AdcpPort <> ComMe) Then
      SerialOpen (AdcpPort,VmBaud,19,0,2000)'open with 2000 byte buffer using format 19
    Else
      SerialOpen (AdcpPort,VmBaud,3,0,2000) 'open ADCP PORT with 2000 byte buffer using format 3
    EndIf
  #EndIf
EndSub

#If WqSonde <> "NONE"
  Sub OpenWQPort
    #If LoggerType = CR6 'For a CR6 the port require a different configuration from a CR1000
        If UseCommsOneForSonde = True Then
        SerialOpen (WqSerialPort,WqBaud,19,0,2000,1)'Max232 requires us to use TTL language, use comms mode one.The Max232 also converts to a binary like signal and requires serial open format of 19 to function. Standard code zero results in a communication error. 
        ElseIf UseCommsZeroForSonde = True Then
        SerialOpen (WqSerialPort,WqBaud,0,0,2000,0)'No Max232 is present so we uses standard RS232 language
        Else
        SerialOpen (WqSerialPort,WqBaud,0,0,2000)'In case we use a non-stanadard port configuration this is the generic code
        EndIf
    #Else 'else it is a CR1000
      If (IsWqMax232 = True) AND (WqSerialPort <> ComME) Then
        SerialOpen (WqSerialPort,WqBaud,19,0,2000)'need to use TTL if Max232 is present
      Else
        SerialOpen (WqSerialPort,WqBaud,0,0,2000)'standard RS232 language works if no Max232 is present
      EndIf
    #EndIf

  EndSub
#EndIf
'_________________________Erase WH Recorder___________________________________
Sub EraseWH
  If CMD = "RE ErAsE" Then 'If command to erase WH recorder is sent then...
    RecEraseString = Mid (Warning,23,15)  'Parse string to get "Recorder erased" from response
  Else
    RecEraseString = ""
  EndIf
  If RecEraseString = "Recorder erased" Then 'if the recorder was successfully erased, flag it in data table
    RecErased = True
  EndIf
  If IfTime (10,1440,min) AND RecErased = True Then 'Reset Recorder erase flag to false at 00:10 (allows time for flag to be written to QAQC table).
    RecErased = False
  EndIf
EndSub

#If GetNoiseFloor = Yes Then
  '__________________________Parse Noise Floor___________________________________
  Sub ParsePT3 'This routine parses the response received from the ADVM when it's been issued a "PT3" command for CHANNEL MASTER ONLY.
    Public PT3String As String * 2000
    'Zero the inputs
    PT3String = ""
    PT3String = Warning
    NoiseFlrParsed = ""
    Erase NoiseHGainW()
    Erase NoiseLGainW()
    Erase NoiseHGainN()
    Erase NoiseLGainN()
    'The final product is the "Noise Floor" for each beam. The commented out sections are for Beams 3 and 4, if we wanted them.
    If (IsCM = False) AND (IsWorkhorse = False) Then ExitSub 'if instrument is not a channel master or Workhorse then exit subroutine
    If CMD = "PT3" Then
      VisitReason = "Sent PT3 Command to ADVM"
      'StartString = InStr (1600,Warning,FilterString,2) 'Parse PT3 response into correct variables
      If IsWorkhorse Then
        'Workhorse parse stuff here
        StartString = InStr (1,PT3String,FilterString,2) 'Parse PT3 response into correct variables
        NoiseFlrParsed = Mid (PT3String,StartString,104)
        NoiseHGainW(1) = Mid (NoiseFlrParsed,10,2)
        NoiseHGainW(2) = Mid (NoiseFlrParsed,15,2)
        NoiseHGainW(3) = Mid (NoiseFlrParsed,20,2)
        NoiseHGainW(4) = Mid (NoiseFlrParsed,25,2)
        NoiseLGainW(1) = Mid (NoiseFlrParsed,50,2)
        NoiseLGainW(2) = Mid (NoiseFlrParsed,55,2)
        NoiseLGainW(3) = Mid (NoiseFlrParsed,60,2)
        NoiseLGainW(4) = Mid (NoiseFlrParsed,65,2)
      Else
        StartString = InStr (1,PT3String,FilterString,2) 'Parse PT3 response into correct variables
        NoiseFlrParsed = Mid (PT3String,StartString,104)
        NoiseHGainW(1) = Mid (NoiseFlrParsed,33,2)
        NoiseHGainW(2) = Mid (NoiseFlrParsed,37,2)
        'NoiseHGainW(3) = Mid (NoiseFlrParsed,41,2)
        'NoiseHGainW(4) = Mid (NoiseFlrParsed,45,2)
        NoiseLGainW(1) = Mid (NoiseFlrParsed,52,2)
        NoiseLGainW(2) = Mid (NoiseFlrParsed,56,2)
        'NoiseLGainW(3) = Mid (NoiseFlrParsed,60,2)
        'NoiseLGainW(4) = Mid (NoiseFlrParsed,64,2)
        NoiseHGainN(1) = Mid (NoiseFlrParsed,71,2)
        NoiseHGainN(2) = Mid (NoiseFlrParsed,75,2)
        'NoiseHGainN(3) = Mid (NoiseFlrParsed,79,2)
        'NoiseHGainN(4) = Mid (NoiseFlrParsed,83,2)
        NoiseLGainN(1) = Mid (NoiseFlrParsed,90,2)
        NoiseLGainN(2) = Mid (NoiseFlrParsed,94,2)
        'NoiseLGainN(3) = Mid (NoiseFlrParsed,98,2)
        'NoiseLGainN(4) = Mid (NoiseFlrParsed,102,2)
      EndIf
    Else
      Warning = ""
    EndIf 'if cmd = pt3
  EndSub
#EndIf 'get noisfloor
'_____________________________Wake VM______This should be modified now that we have the ability to turn the VM on and off__________________
#If HasVM Then
  Sub WakeVM
    'send a CS command To wake up VM in Case it has gone To sleep
    'SerialOut (AdcpPort,"+++","",0,100)'send alt break command
    Banner = ""
    CSCmd = ""
    Call CycleVmPower 'give it a jolt and then send a CS command
    Call OpenAdcpPort
    If IsVADCP = True Then
      SerialOut (AdcpPort,"+++","",0,100)'send alt break command
      Delay (1,1,Sec)'wait for reply
      SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
      SerialFlush (AdcpPort)
      SerialOut (AdcpPort,"CSTOP" + CHR(13) + CHR(10),"",0,100)
      SerialIn (CSCmd,AdcpPort,100,-1,100)
      SerialFlush (AdcpPort)
      Delay (1,1,Sec)
      SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
      SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
      SerialFlush (AdcpPort)
      VMRestartAttempts = VMRestartAttempts + 1
    Else
      Delay (1,1,Sec)'wait for reply
      SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
      SerialFlush (AdcpPort)
      SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
      SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
      SerialFlush (AdcpPort)
      VMRestartAttempts = VMRestartAttempts + 1
    EndIf
    VmDeadCount = 0 'set to zero and try again
  EndSub
#EndIf
'the program uses less ADCP processing time if the ADCP and Logger times are synchronized
'So this Sub is called to Sychronize the logger and VM times
'--------------------------------------------------------------------
Sub SetVMTime
  VMTimeStart = Timer(2,msec,4)
  VMTimeStart = VMTimeStart/1000
  Call CycleVmPower
  'The set time command to the VM Requires leading zeros, so the logger timestamp is split out and leading zeros added if needed
  RawSetTime = Status.Timestamp 'get latest time from datalogger
  SplitStr (SplitTime(),RawSetTime," ",6,0) 'take apart the time string
  #If Debugging = True Then
    Public SendVMMonth As String
    Public SendVMDay As String
    Public SendVmHour As String
    Public SendVmMin As String
    Public SendVmSec As String
    Public SendVmYear As String
  #Else
    Dim SendVMMonth As String
    Dim SendVMDay As String
    Dim SendVmHour As String
    Dim SendVmMin As String
    Dim SendVmSec As String
    Dim SendVmYear As String
  #EndIf
  If SplitTime(1) < 10 Then  'add leading zeros if needed
    SendVMMonth = "0" + SplitTime(1)
  Else
    SendVMMonth = SplitTime(1)
  EndIf
  If SplitTime(2) < 10 Then
    SendVMDay = "0" + SplitTime(2)
  Else
    SendVMDay = SplitTime(2)
  EndIf
  If SplitTime(4) < 10 Then
    SendVmHour = "0" + SplitTime(4)
  Else
    SendVmHour = SplitTime(4)
  EndIf
  If SplitTime(5) < 10 Then
    SendVmMin = "0" + SplitTime(5)
  Else
    SendVmMin = SplitTime(5)
  EndIf
  If Round(SplitTime(6),0) < 10 Then
    SendVmSec = "0" + Round(SplitTime(6),0) 'eliminate fractional seconds
  Else
    SendVmSec = Round(SplitTime(6),0)
  EndIf
  SendVmYear = Right(SplitTime(3),2)
  VMTimeString = "TS" + SendVmYear + "/" + SendVMMonth + "/" + SendVMDay + "," + SendVmHour + ":" + SendVmMin + ":" + SendVmSec 'Reconstruct time string

  Call OpenADCPPort
  If IsVADCP = True Then 'the VADCP needs a CSTOP command to get into command mode
    SerialOut (AdcpPort,"+++","",0,100)'send alt break command
    Delay (1,1,Sec)'wait for reply
    SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,"CSTOP" + CHR(13) + CHR(10),"",0,100)
    SerialIn (Warning,AdcpPort,100,-1,100)
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,VMTimeString + CHR(13) + CHR(10),"",0,100)
    SerialIn (Warning,AdcpPort,100,-1,100) 'get echo of CS command
    Delay (1,1,Sec)'wait for reply
    SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
    SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
    SerialFlush (AdcpPort)
    'RestartAttempts = RestartAttempts + 1
  Else
    SerialOut (AdcpPort,"+++","",0,100)'send alt break command
    Delay (1,1,Sec)'wait for reply
    SerialIn (Banner,AdcpPort,100,-1,100)'get banner from ADCP
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,VMTimeString + CHR(13) + CHR(10),"",0,100)
    SerialIn (Warning,AdcpPort,100,-1,100) 'get echo of CS command
    Delay (1,1,Sec)'wait for reply
    SerialOut (AdcpPort,"CS"+ CHR(13) + CHR(10),"",0,100)
    SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
  EndIf
  SetVMTimeFlg = false 'set the flag back to false until next time sychro
  VMTimeEnd = Timer(2,msec,4)
  VMTimeEnd = VMTimeEnd/1000
  VMTotTime = VMTimeEnd - VMTimeStart
EndSub
'Set time on EXO
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub SetEXOTime
    'The set time command to the VM Requires leading zeros, so the logger timestamp is split out and leading zeros added if needed
    RawSetTime = Status.Timestamp 'get latest time from datalogger
    SplitStr (SplitTime(),RawSetTime," ",6,0) 'take apart the time string
    Public SendEXOHour As String
    Public SendEXOMin As String
    Public SendEXOSec As String
    Public CalcHour As Float
    CalcHour = SplitTime(4)
    If DWRSonde = False Then
    CalcHour = CalcHour + 8
    Else
    CalcHour = CalcHour
    EndIf
    If CalcHour >= 24 Then CalcHour = CalcHour - 24

    If CalcHour < 10 Then 'add leading zero to hour
      SendEXOHour = "0" + CalcHour
    Else
      SendEXOHour = CalcHour
    EndIf
    If SplitTime(5) < 10 Then
      SendEXOMin = "0" + SplitTime(5)
    Else
      SendEXOMin = SplitTime(5)
    EndIf
    If Round(SplitTime(6),0) < 10 Then
      SendEXOSec = "0" + Round(SplitTime(6),0) 'eliminate fractional seconds
    Else
      SendEXOSec = Round(SplitTime(6),0)
    EndIf
    EXOTimeString = SendEXOHour + ":" + SendEXOMin + ":" + SendEXOSec 'Reconstruct UTC time string to send to EXO
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"time " + EXOTimeString + CHR(13) + CHR(10),"OK",3,50)
    Delay (1,200,mSec)
    SerialFlush(WqSerialPort)
    SerialClose(WqSerialPort)
    SetEXOTimeFlg = False
  End Sub
#EndIf
'________________________________Cycle VM Power -- This is used similarly to the 'break' command because the CR1000 does not seem to have the ability to
'generate a break signal from its existing firmware -- I'm sure it's available in the UART, it's just not implimented!! _________________________________
'If power switch is installed then cycle VM power
Sub CycleVMPower
  '  If PowerSwitch = True Then
  Select Case IsSubmersed
  Case False
    SerialFlush (AdcpPort)
    'Turn Power on and off to ADCP assuming NC relay
    If isVMNClosed Then
      PortSet (VMSwitchPort,1 )
      Delay (1,3,Sec)
      PortSet (VMSwitchPort,0)
    Else
      PortSet (VMSwitchPort,0 )
      Delay (1,3,Sec)
      PortSet (VMSwitchPort,1)
    EndIf
  Case True
    SerialFlush (AdcpPort)
    #If LoggerType = CR1000 Then SW12(0)
    #ElseIf LoggerType = CR6 Then SW12(1,0)
    #EndIf
    Delay (1,3,Sec)
    #If LoggerType = CR1000 Then SW12(1)
    #ElseIf LoggerType = CR6 Then SW12(1,1)
    #EndIf
  EndIf
  '  EndIf
EndSub
'_________________________________Turns VM Off if user selected VMPower = false __________________________________________________________________
Sub ToggleVMPower
  '  If PowerSwitch = True
  Select Case IsSubmersed
  Case False
    If VMPower = True Then
      ExitSub
    EndIf
    If VMPower = False Then
      SerialFlush (AdcpPort)
      'Turn Power on and off to ADCP
      If isVMNClosed Then
        PortSet (VMSwitchPort,1) 'assumes NC relay
      Else
        PortSet (VMSwitchPort,0) 'NO relay
      EndIf
    EndIf
  Case True
    If VMPower = True Then
      #If LoggerType = CR1000 Then SW12(1)
      #ElseIf LoggerType = CR6 Then SW12(1,1)
      #EndIf
      ExitSub
    Else
      SerialFlush (AdcpPort)
      #If LoggerType = CR1000 Then SW12(0)
      #ElseIf LoggerType = CR6 Then SW12(1,0)
      #EndIf
    EndIf
  End Select
  '  EndIf
EndSub

'_____________________Check VM Recorder Memory Free__________________
Sub GetVMFreeMem
  Banner = ""
  Warning = ""
  If IsWorkhorse = False Then ExitSub
  If IfTime(10,1440,Min) AND RecCalibData = False Then
    SerialOut (AdcpPort,"+++" + CHR(13) + CHR(10),"",0,100) 'Send ALT+Break
    SerialIn (Banner,AdcpPort,500,">",200) 'Get response in "Banner"
    SerialIn (Prompt,AdcpPort,100,-1,100)  'Get response in "Prompt"
    SerialFlush (AdcpPort)
    Delay (1,500,mSec)
    SerialOut (AdcpPort,"RS?" + CHR(13) + CHR(10),"",0,100) 'Send "RS?" to check see how much memory is free on WH recorder
    SerialIn (VMMemString,AdcpPort,150,-1,150) 'Get response back from "RS?" command in "VMMemString" variable
    SerialFlush (AdcpPort)
    SerialOut (AdcpPort,"CS" + CHR(13) + CHR(10),"",0,100)'CS command to start pinging
    SerialIn (CSCmd,AdcpPort,100,-1,100) 'get echo of CS command
    SerialFlush (AdcpPort)
    SendCMD = False
    VMMemFree = Mid (VMMemString,17,3)    ' Parse amount of memory free out of VM Response
  Else
    VMMemString = "" 'make this string blank
    If VMMemFree <= VMLowMemVal Then      'Set flag to notify if low memory on VM (determined per site), how many times?
      VMLowMem = True
      VMLowMemCount = VMLowMemCount + 1
    Else
      VMLowMem = False
      VMLowMemCount = 0
    EndIf
    If VMMemFree = 0 Then                 'Set Flag to notify if VM is out of memory, how many times?
      VMNoMem = True
      VMNoMemCount = VMNoMemCount + 1
    Else
      VMNoMem = False
      VMNoMemCount = 0
    EndIf
  EndIf
EndSub
'----------------------------------------------------------------------------------------------
'define EXO data locations
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub DefineLocs 'tells datalogger where to put the parameters.
    WqLocDate = t(1)
    WqLocTime = t(2)
    WqLocTempC = t(3)
    WqLocTempF = t(4)
    WqLocCond = t(5)
    WqLocTurbFNU = t(6)
    WqLocDoSat = t(7)
    WqLocDOmgL = t(8)
    WqLocDepth = t(9)
    WqLocBatt = t(10)
    WqLocpH = t(11)
    WqLocpHmV = t(12)
    WqLocORP = t(13)
    WqLocChlugL = t(14)
    WqLocChlRFU = t(15)
    WqLocBGApcRFU = t(16)
    WqLocBGApcugL = t(17)
    WqLocFDomRFU = t(18)
    WqLocFDomQSU = t(19)
    WqLocNH4 = t(20)
    WqLocNO3 = t(21)
    WqLocCL = t(22)
    WqLocWiperPos = t(23)
  EndSub
#EndIf
'-----------------------------Parameter check-----Gets the parameter order from serial connected EXO sondes-----
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub ParamCheck 'gets the parameter codes from the EXO in whichever order they are being output
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"para" + CHR(13) + CHR(10),"",1,0)
    Delay (1,300,mSec)
    SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
    WqIn = Trim(WqIn)
    SplitStr (WqParamOrder,WqIn,CHR(32),WqNparams,0)
    NoSondeTrig = InStr(1,WqIn,"Sonde",2)
    Delay (1,200,mSec)
    SerialFlush(WqSerialPort)
    SerialClose(WqSerialPort)
  EndSub
#EndIf
' SetDilim -----------Sets the serial connected EXO to comma delimited output----
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub SetDelim 'sets the EXO to comma delimited output
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"setdelim 2" + CHR(13) + CHR(10),"OK",3,50)
    Delay (1,300,mSec)
    SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
    NoSondeTrig = InStr(1,WqIn,"Sonde",2)
    Delay (1,20,mSec)
    SerialFlush(WqSerialPort)
    SerialClose(WqSerialPort)
  EndSub
#EndIf
'----------GetWQ_Serial------Gets a single set of data from the serial connected EXO
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub GetWQ_Serial 'gets single data point from EXO
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,10,mSec)
    SerialOut (WqSerialPort,"data" + CHR(13) + CHR(10),"",1,0)
    Delay (1,200,mSec)
    SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
    Erase WqData()
    WqIn = Trim(WqIn)
    SplitStr (WqData,WqIn,",",WqNparams,0)
    NoSondeTrig = InStr(1,WqIn,"Sonde",2)
    Delay (1,20,mSec)
    SerialFlush(WqSerialPort)
    SerialClose(WqSerialPort)
  EndSub
#EndIf
'-----------------Parses data from a serial connected EXO ------------------
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub ParseData 'Parses data into correct locations
    If (WqData(WqLocDate) <> NAN) AND (WqData(WqLocDate)<> 0) AND (WqData(WqLocTime)<> OldEXOTime)  Then
      OldEXOTime = WqData(WqLocTime)
      WqError = False
      WqDead = False
      'WqDeadCnt = 0
      WqErrCount = 0
      WqPwrCycleCnt = 0
    Else
      WqError = True
      OldEXOTime = WqData(WqLocTime)
      #If DWRSonde = False Then 
      Call WQ_Mark_Bad
      Exit Sub
      #EndIf
    EndIf
    If WqLocDate > 0 Then WqDate = WqData(WqLocDate)
    If WqLocTime > 0 Then WqTime = WqData(WqLocTime)
    If WqLocTempC > 0 Then WqTempC = WqData(WqLocTempC)
    If WqLocTempF > 0 Then WqTempF = WqData(WqLocTempF)
    If WqLocCond > 0 Then WqSpCond = WqData(WqLocCond)
    If WqLocTurbFNU > 0 Then WqTurbFNU = WqData(WqLocTurbFNU)
    If WqLocDoSat > 0 Then WqDOSat = WqData(WqLocDoSat)
    If WqLocDOmgL > 0 Then WqDOMgl = WqData(WqLocDOmgL)
    If WqLocDepth > 0 Then WqDepthFt = WqData(WqLocDepth)
    If WqLocBatt > 0 Then WqBattV = WqData(WqLocBatt)
    If WqLocpH > 0 Then WqPH = WqData(WqLocpH)
    If WqLocpHmV > 0 Then WqPHmv = WqData(WqLocpHmV)
    If WqLocORP > 0 Then WqORP = WqData(WqLocORP)
    If WqLocChlugL > 0 Then WqChlugL = WqData(WqLocChlugL)
    If WqLocChlRFU > 0 Then WqChlRFU = WqData(WqLocChlRFU)
    If WqLocBGApcRFU > 0 Then WqBGArfu = WqData(WqLocBGApcRFU)
    If WqLocBGApcugL > 0 Then WqBGAugl = WqData(WqLocBGApcugL)
    If WqLocFDomRFU > 0 Then WqFDOMrfu = WqData(WqLocFDomRFU)
    If WqLocFDomQSU > 0 Then WqFDOMqsu = WqData(WqLocFDomQSU)
    If WqLocNH4 > 0 Then WqNH4mgl = WqData(WqLocNH4)
    If WqLocNO3 > 0 Then WqNO3mgl = WqData(WqLocNO3)
    If WqLocCL > 0 Then WqCLmgl = WqData(WqLocCL)
    If WqLocWiperPos > 0 Then WqWiperPos = WqData(WqLocWiperPos)
  EndSub
#EndIf
'-------------------DefineParamsOrder----Automatically determines the order of the incoming serial connected EXO data ------
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub DefineParamsOrder 'used to automatically determine which order parameters are coming in
    t(1) = FindSpa (DateCode,DateCode,1,WqParamOrder())
    t(2) = FindSpa (TimeCode,TimeCode,1,WqParamOrder())
    t(3) = FindSpa (TempCCode,TempCCode,1,WqParamOrder())
    t(4) = FindSpa (TempFCode,TempFCode,1,WqParamOrder())
    t(5) = FindSpa (CondCode,CondCode,1,WqParamOrder())
    t(6) = FindSpa (TurbFNUCode,TurbFNUCode,1,WqParamOrder())
    t(7) = FindSpa (DoSatCode,DoSatCode,1,WqParamOrder())
    t(8) = FindSpa (DOmgLCode,DOmgLCode,1,WqParamOrder())
    t(9) = FindSpa (DepthCode,DepthCode,1,WqParamOrder())
    t(10) = FindSpa (BattCode,BattCode,1,WqParamOrder())
    t(11) = FindSpa (pHCode,pHCode,1,WqParamOrder())
    t(12) = FindSpa (pHmVCode,pHmVCode,1,WqParamOrder())
    t(13) = FindSpa (ORPCode,ORPCode,1,WqParamOrder())
    t(14) = FindSpa (ChlugLCode,ChlugLCode,1,WqParamOrder())
    t(15) = FindSpa (ChlRFUCode,ChlRFUCode,1,WqParamOrder())
    t(16) = FindSpa (BGApcRFUCode,BGApcRFUCode,1,WqParamOrder())
    t(17) = FindSpa (BGApcugLCode,BGApcugLCode,1,WqParamOrder())
    t(18) = FindSpa (FDomRFU,FDomRFU,1,WqParamOrder())
    t(19) = FindSpa (FDomQSU,FDomQSU,1,WqParamOrder())
    t(20) = FindSpa (NH4Code,NH4Code,1,WqParamOrder())
    t(21) = FindSpa (NO3Code,NO3Code,1,WqParamOrder())
    t(22) = FindSpa (CLCode,CLCode,1,WqParamOrder())
    t(23) = FindSpa (WiperPos,WiperPos,1,WqParamOrder())

  EndSub
#EndIf
' -------------------SetBurst-------if collecting burst then Setup EXO for burst-----
#If WqSonde = "WQ_SERIAL_BURST" Then
  Sub SetBurst 'sets to run and receives string
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay (1,20,mSec)
        #If LoggerType = CR6 Then 'if we are using a CR6 we can use a faster period. 1000 worked with no issues but changed to 1150 so we have continuity in sampling rate between loggers. Can be altered in the future if needed.
      SerialOut (WqSerialPort,"setperiod " + BurstPeriod + CHR(13) + CHR(10),"OK",3,50)
    #Else 'a CR1000's slower processing speed require a slower period to not miss data coming from the sonde during a burst. Do not go below 1150. 1138 was the quickest tested speed that resulted in no errors. Added a little extra time as a buffer.
      SerialOut (WqSerialPort,"setperiod " + BurstPeriod + CHR(13) + CHR(10),"OK",3,50)
    #EndIf
    'We won't use baude rate 9600 any more
'    #If WqBaud = 9600 Then 
'      SerialOut (WqSerialPort,"setperiod 1170" + CHR(13) + CHR(10),"OK",3,50)
'    #Else
'      SerialOut (WqSerialPort,"setperiod 1000" + CHR(13) + CHR(10),"OK",3,50)
'    #EndIf
    Delay (1,200,msec)
    SerialOut (WqSerialPort,"#" + CHR(13),"#" + CHR(13),3,100)
    SerialOut (WqSerialPort,"run" + CHR(13),"run" + CHR(13),3,10) 'Starts the Wq sampling at 1Hz
    Delay (1,1,Sec)
  End Sub
  Sub GetBurstArray 'Gets 30 second burst from sonde and stores in burst array
    BurstCount = 0
    Dim Lcount As Long
    For Lcount = 1 To 30
      SerialIn (BurstIn,WqSerialPort,100,"#",150)
      Delay(1,50,mSec)
      If BurstIn = "" Then
        WqError = true
        iCount = 1
        Exit Sub
      EndIf
      BurstIn = Replace (BurstIn,"-nan","-9999")
      SplitStr (BurstArray(iCount,1),BurstIn,CHR(32),17,0)'parse the raw string and store in burst array (process after loop)
      Delay(1,20,mSec)
      Erase(BurstIn)
      SerialFlush(WqSerialPort)
      iCount = iCount+1
      #If WqBaud = 9600 Then
        Delay(1,1100,mSec)'needs a little extra time at 9600 baud
      #Else
        Delay (1,930,mSec)
      #EndIf
    Next Lcount
    Delay (1,20,mSec)
    SerialOut (WqSerialPort,"0" + CHR(13) + CHR(10),"#",3,50)
    SerialClose(WqSerialPort)
  End Sub
#EndIf
'------ParseBurst---------if collecting burst with Wq then parse the burst------------------------
#If WqSonde = "WQ_SERIAL_BURST" Then
  Sub ParseBurst 'Parses burst data into correct locations
    If (BurstData(WqLocDate) <> NAN) AND (BurstData(WqLocDate) <> 0) Then
      WqError = False
      WqDead = False
      WqErrCount = 0
      WqPwrCycleCnt = 0
      'WqDeadCnt = 0
    Else
      WqError = True
    EndIf
    If WqLocDate > 0 Then BurstDate = BurstData(WqLocDate)
    If WqLocTime > 0 Then BurstTime = BurstData(WqLocTime)
    If WqLocTempC > 0 Then BurstTempC = BurstData(WqLocTempC)
    If WqLocTempF > 0 Then BurstTempF = BurstData(WqLocTempF)
    If WqLocCond > 0 Then BurstSpCond = BurstData(WqLocCond)
    If WqLocTurbFNU > 0 Then BurstTurbFNU = BurstData(WqLocTurbFNU)
    If WqLocDoSat > 0 Then BurstDOSat = BurstData(WqLocDoSat)
    If WqLocDOmgL > 0 Then BurstDOmgL = BurstData(WqLocDOmgL)
    If WqLocDepth > 0 Then BurstDepthFt = BurstData(WqLocDepth)
    If WqLocBatt > 0 Then BurstBattV = BurstData(WqLocBatt)
    If WqLocpH > 0 Then BurstpH = BurstData(WqLocpH)
    If WqLocpHmV > 0 Then BurstpHmV = BurstData(WqLocpHmV)
    If WqLocORP > 0 Then BurstORP = BurstData(WqLocORP)
    If WqLocChlugL > 0 Then BurstChlugL = BurstData(WqLocChlugL)
    If WqLocChlRFU > 0 Then BurstChlRFU = BurstData(WqLocChlRFU)
    If WqLocBGApcRFU > 0 Then BurstBGApcRFU = BurstData(WqLocBGApcRFU)
    If WqLocBGApcugL > 0 Then BurstBGApcugL = BurstData(WqLocBGApcugL)
    If WqLocFDomRFU > 0 Then BurstFdomRFU = BurstData(WqLocFDomRFU)
    If WqLocFDomQSU > 0 Then BurstFDomQSU = BurstData(WqLocFDomQSU)
    If WqLocNH4 > 0 Then BurstNH4Amgl = BurstData(WqLocNH4)
    If WqLocNO3 > 0 Then BurstNO3Nmgl = BurstData(WqLocNO3)
    If WqLocCL > 0 Then BurstCLmgl = BurstData(WqLocCL)
    If WqLocWiperPos > 0 Then BurstWiperPos = BurstData(WqLocWiperPos)
  EndSub
#EndIf

'------------------Set Burst Variables to NAN-------------------------------
'Prevent duplicate values from being populated in case new values don't get read in in time. Set all values to NAN until they're actually populated by the burst
#If (WqSonde = "WQ_SERIAL_BURST") Then
  Sub ResetBurstVars
    MedBurstDate = BadDataIndicator
    MedBurstTime = BadDataIndicator
    MedTempC = BadDataIndicator
    MedTempF = BadDataIndicator
    MedSpCond = BadDataIndicator
    MedTurbFNU = BadDataIndicator
    MedDOSat = BadDataIndicator
    MedDOmgL= BadDataIndicator
    MedORP= BadDataIndicator
    MedDepthFt = BadDataIndicator
    MedBattV= BadDataIndicator
    MedpH= BadDataIndicator
    MedpHmV= BadDataIndicator
    MedChlugL= BadDataIndicator
    MedChlRFU= BadDataIndicator
    MedBGApcRFU= BadDataIndicator
    MedBGApcugL= BadDataIndicator
    MedFdomRFU= BadDataIndicator
    MedFDomQSU= BadDataIndicator
    MedNH4Amgl= BadDataIndicator
    MedNO3Nmgl= BadDataIndicator
    MedCLmgl= BadDataIndicator
    MedWiperPos= BadDataIndicator
  EndSub
  
'_______________________Copy the calculated medians to a variable to be sampled into the Aquarius table___________________
Sub CopyMedBurstVals
          MedBurstDate = Burst.BurstDate_Med
          MedBurstTime = Burst.BurstTime_Med
          MedBurstTime = Round(MedBurstTime,0) 'round the time because the median value of an even set of numbers is the average of the two median values
          MedTempC = Burst.BurstTempC_Med
          MedTempF = Burst.BurstTempF_Med
          MedSpCond = Burst.BurstSpCond_Med
          MedTurbFNU = Burst.BurstTurbFNU_Med
          MedDOSat = Burst.BurstDOSat_Med
          MedDOmgL= Burst.BurstDOmgL_Med
          MedORP= Burst.BurstORP_Med
          MedDepthFt = Burst.BurstDepthFt_Med
          MedBattV= Burst.BurstBattV_Med
          MedpH= Burst.BurstpH_Med
          MedpHmV= Burst.BurstpHmV_Med
          MedChlugL= Burst.BurstChlugL_Med
          MedChlRFU= Burst.BurstChlRFU_Med
          MedBGApcRFU= Burst.BurstBGApcRFU_Med
          MedBGApcugL= Burst.BurstBGApcugL_Med
          MedFdomRFU= Burst.BurstFdomRFU_Med
          MedFDomQSU= Burst.BurstFDomQSU_Med
          MedNH4Amgl= Burst.BurstNH4Amgl_Med
          MedNO3Nmgl= Burst.BurstNO3Nmgl_Med
          MedCLmgl= Burst.BurstCLmgl_Med
          MedWiperPos= Burst.BurstWiperPos_Med
          EndSub
#EndIf

'-------WipWQ-----Wipe the serial connected EXO sensors----------------------------------------
#If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
  Sub WipeWq 'tells Wq to wipe
    Call OpenWQPort
    SerialOut (WqSerialPort,"0" + CHR(13),"?Command",3,10)
    Delay(1,10,mSec)
    SerialOut (WqSerialPort,"twipeb" + CHR(13) + CHR(10),"",1,0)
    SerialIn (WqIn,WqSerialPort,100,&H0D0A,200)
    SplitStr (WqDelay,WqIn,"",1,0)
    '  If WqDelay > -1 AND WqDelay <> NAN Then
    '    Timer(1,Sec,2)
    '    Do
    '      TempLong = Timer (1,Sec,4)
    '    Loop Until TempLong >= (WqDelay + 1)
    '  EndIf
  EndSub
  'if operator sets the manual power cycle flag then cycle WQ power
#EndIf

'----------CycleWQPower-----------Switches off the WQ power until the next Scan ------------
#If (WqSonde <> "NONE") Then
  Sub CycleWQPower
    #If LoggerType = CR1000 Then
      If IsWQNClosed Then
        PortSet(WqSwitchPort,1)
      Else
        PortSet(WqSwitchPort,0)
      EndIf 'is normally closed
    #ElseIf LoggerType = CR6 Then
      If  UseSW12_2_forWQ Then 'using SW12 port 2
        SW12(2,0)
      Else
        If IsWQNClosed Then
          PortSet(WqSwitchPort,1)
        Else
          PortSet(WqSwitchPort,0)
        EndIf
      EndIf
    #EndIf
    WqPwrCycleCnt = 0
    WqManualCycle = False
    Delay(1,15,sec)'let exo warm up
    ErrorEvent = "Cycle Sonde Power"
    #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
      Redeploy = true
    #EndIf
  EndSub
#EndIf
'--------GetWq_SDI12------Gets one dataset from the SDI12 connected Sonde
#If WqSonde = "WQ_SDI12" Then
  '___________________________Get YSI Sonde Data_______________________
  Sub GetWq_SDI12
    'first see if YSI or EXO Sonde is turned on...
    'YsiSonde = LowerCase(YsiSonde)
    'If YsiSonde = "yes" Then 'if user picked yes from keypad
    'first initialize variables
    'Get YSI Sonde data
    Select Case WqSDIPort 'based upon keypad choice
    Case 3
      SDI12Recorder (WqSDI12Sensor(),WqCom3,WqAddr,"C!",1.0,0)
    Case 5
      SDI12Recorder (WqSDI12Sensor(),wqCom5,WqAddr,"C!",1.0,0)
    EndSelect
    If (WqSDI12Sensor(1) <> NAN) AND (WqSDI12Sensor(1) <> 0)  Then 'if data came through then
      WqError = No
      WqErrCount = 0
      WqDead = No 'if we're getting data again let's reset the Wq counters
      'WqDeadCnt = 0
      'let's assign meaningful variable names to YSI data - based upon keypad choices.
      If LocTempC > 0 Then WqTempC = WqSDI12Sensor(LocTempC)
      If LocSpCond > 0 Then WqSpCond = WqSDI12Sensor(LocSpCond)
      If MilliToMicro = Yes Then WqSpCond = WqSpCond * 1000
      If LocVolts > 0 Then WqBattV = WqSDI12Sensor(LocVolts)
      If LocDOmgL > 0 Then WqDOMgl = WqSDI12Sensor(LocDOmgL)
      If LocDOSat > 0 Then WqDOSat = WqSDI12Sensor(LocDOSat)
      If LocPH > 0 Then WqPH = WqSDI12Sensor(LocPH)
      If LocORP > 0 Then WqORP = WqSDI12Sensor(LocORP)
      If LocDepth > 0 Then WqDepthFt = WqSDI12Sensor(LocDepth)
      If LocTurbFNU > 0 Then WqTurbFNU = WqSDI12Sensor(LocTurbFNU)
      If LocFdomRFU > 0 Then WqFDOMrfu = WqSDI12Sensor(LocFdomRFU)
      If LocFdomQSU > 0 Then WqFDOMqsu = WqSDI12Sensor(LocFdomQSU)
      If LocChlorMGL > 0 Then WqChlugL = WqSDI12Sensor(LocChlorMGL)
      If LocChlorRFU > 0 Then WqChlRFU = WqSDI12Sensor(LocChlorRFU)
      If LocBGA > 0 Then WqBGAugl = WqSDI12Sensor(LocBGA)
      If LocAmmonium > 0 Then WqNH4mgl = WqSDI12Sensor(LocAmmonium)
      If LocNitrate > 0 Then WqNO3mgl = WqSDI12Sensor(LocNitrate)
      If LocChloride > 0 Then WqCLmgl = WqSDI12Sensor(LocChloride)
      If LocWiperPos > 0 Then WqWiperPos = WqSDI12Sensor(LocWiperPos)
      WqTempF = WqTempC*1.8+32
      '____________________TESTING THE FOLLoWING_____________________________________________________________
      '____________________Won't affect any measurements____________________________________________________
      Wiper1Min = Data1m.wqWiperPos
      If WqWiperPos > Data1m.wqWiperPos + 0.1 OR WqWiperPos < Data1m.wqWiperPos - 0.1 Then
        WiperErrCount = WiperErrCount + 1
      Else
        WiperErrCount = 0
        WiperTestCount = WiperTestCount + 1
      EndIf
      If WiperErrCount >= 15 Then
        WiperOut = True
      Else
        WiperOut = False
      EndIf
      If WqWiperPos < Data1m.wqWiperPos + 0.1 AND WqWiperPos > Data1m.wqWiperPos - 0.1 Then
        WiperInCount = WiperInCount + 1
      EndIf
      '_______________TESTING ABOVE___________________________________________________________________________
      '
    Else 'we have no data

      WqErrCount = WqErrCount + 1
      WqPwrCycleCnt = WqPwrCycleCnt + 1
      WqError = True
      'WqSdiErr = Yes 'used to flag data for sys info file
      WqBattV = -999999 'flag volts to more easily see if problem
      WqSDI12Sensor() = NAN 'flag all WqSDI12Sensors to NAN to easily see there's a problem
      Call WQ_Mark_Bad
      If WqDead Then 'YSI has sent no data for an hour or more
        'need to change this to wqswitchport
        Call CycleWQPower
        'reset dead counter
        'WqDeadCnt = 0
        'set Wq to be alive again
      Else
        'were still counting up the Wq dead minutes
        If WqErrCount >= WQDeadCntMax Then
          WqDead = Yes
        Else
          WqDead = No
        EndIf
      EndIf
      '      If YsiWiperPos > Data1m.YsiWiperPos + 0.1 OR YsiWiperPos < Data1m.YsiWiperPos - 0.1 Then
      '        WiperErrCount = WiperErrCount + 1
      '      Else
      '        WiperErrCount = 0
      '        WiperTestCount = WiperTestCount + 1
      '      EndIf
      '      If WiperErrCount >= 15 Then
      '        WiperOut = True
      '      Else
      '        WiperOut = False
      '      EndIf
      '      If YsiWiperPos < Data1m.YsiWiperPos + 0.1 AND YsiWiperPos > Data1m.YsiWiperPos - 0.1 Then
      '        WiperInCount = WiperInCount + 1
      '      EndIf
    EndIf
  EndSub
#EndIf

'--------WQ_Mark_Bad-------- If no incoming data mark it bad
#If (WqSonde <> "NONE") Then
  Sub WQ_Mark_Bad 'if WQerror then Zero all wqdata
    WqDate = ""
    WqTime =""
    'Public WqNparams As Long
    WqTempC = BadDataIndicator
    WqTempF = BadDataIndicator
    WqSpCond = BadDataIndicator
    WqTurbFNU = BadDataIndicator
    WqChlugL = BadDataIndicator
    WqChlRFU = BadDataIndicator
    WqDOMgl = BadDataIndicator
    WqDOSat = BadDataIndicator
    WqPH = BadDataIndicator
    WqPHmv = BadDataIndicator
    WqORP = BadDataIndicator
    WqDepthFt = BadDataIndicator
    WqBattV = BadDataIndicator
    WqBGAugl = BadDataIndicator
    WqBGArfu = BadDataIndicator
    WqFDOMrfu = BadDataIndicator
    WqFDOMqsu = BadDataIndicator
    WqNH4mgl = BadDataIndicator
    WqNO3mgl = BadDataIndicator
    WqCLmgl = BadDataIndicator
    WqWiperPos = BadDataIndicator
  EndSub
#EndIf
'___________________New Stage Subroutine______________________________
Sub GetStage
  If IsWorkhorse Then
    VMpressure = WHpressure 'It's a workhorse and there is no "VMPress" from CM
  EndIf
  Call GetPSPress 'Get SDI-12 data from PS1
  Call GetPsPress2 'Get SDI-12 data from PS2
  UpBeamStg = VMupBeam + UpBeamOffset
  VMPressStg = VMpressure + VMPressOffset
  PS1Stg = PsPress1Stg(1) + PS1Offset
  PS2Stg = PSpress2Stg(1) + PS2Offset
  #If WqSonde <> "NONE" Then
    SondeStg = WqDepthFt + SondeOffset
  #EndIf
  Select Case SelStgPrime
  Case UPbeam 'User selected Upbeam to be used as Stage
    If (VMdataIn = Yes AND VMupBeam <> NAN) Then 'If there are data coming in and they are valid
      StagePrime = UpBeamStg
      BadStgFlag = No
    Else 'otherwise flag data as bad
      BadStgFlag = Yes
      StagePrime = BadDataIndicator
    EndIf
  Case VMpress 'User Selected VM Pressure sensor to be used as stage
    If (VMdataIn = Yes AND VMpressure <> NAN) Then 'If there are data coming in and they are valid
      StagePrime = VMPressStg
      BadStgFlag = No
    Else ' Otherwise flag data as bad
      BadStgFlag = Yes
      StagePrime = BadDataIndicator
    EndIf
  Case PSpress 'User selected Pressure sensor 1 to be used as stage
    If PSPressDataIn = Yes Then
      StagePrime = PS1Stg
      BadStgFlag = No
    Else ' Otherwise flag data as bad
      BadStgFlag = Yes
      StagePrime = BadDataIndicator
    EndIf
  Case PSpress2 'User selected Pressure Sensor 2 to be used as stage
    If PSpress2DataIn = Yes Then 'if there are data then
      StagePrime = PS2Stg
      BadStgFlag = No
    Else 'otherwise flag the data as bad
      BadStgFlag = Yes
      StagePrime = BadDataIndicator
    EndIf
    'need all sondes checked for stage
    #If WqSonde <> "NONE" Then
    Case WqPress 'User selected YSI for Stage
      'Get YSI Stage Data
      If WqError = No Then 'If there are data then
        StagePrime = SondeStg
        BadStgFlag = No
      Else 'Otherwise flag the data as bad
        BadStgFlag = Yes
        StagePrime = BadDataIndicator
      EndIf
    #EndIf
  EndSelect

  Select Case SelStgSecnd
  Case UPbeam 'User selected Upbeam to be used as Stage
    If (VMdataIn = Yes AND VMupBeam <> NAN) Then 'If there are data coming in and they are valid
      StageSecnd = UpBeamStg
    Else 'otherwise flag data as bad
      StageSecnd = BadDataIndicator
    EndIf
  Case VMpress 'User Selected VM Pressure sensor to be used as stage
    If (VMdataIn = Yes AND VMpressure <> NAN) Then 'If there are data coming in and they are valid
      StageSecnd = VMPressStg
    Else ' Otherwise flag data as bad
      StageSecnd = BadDataIndicator
    EndIf
  Case PSpress 'User selected Pressure sensor 1 to be used as stage
    If PSPressDataIn = Yes Then
      StageSecnd = PS1Stg
    Else ' Otherwise flag data as bad
      StageSecnd = BadDataIndicator
    EndIf
  Case PSpress2 'User selected Pressure Sensor 2 to be used as stage
    If PSpress2DataIn = Yes Then 'if there are data then
      StageSecnd = PS2Stg
    Else 'otherwise flag the data as bad
      StageSecnd = BadDataIndicator
    EndIf
    #If WqSonde <> "NONE" Then
    Case WqPress 'User selected YSI for Stage
      'Get YSI Stage Data
      If WqError = No Then 'If there are data then
        StageSecnd = SondeStg
      Else 'Otherwise flag the data as bad
        StageSecnd = BadDataIndicator
      EndIf
    #EndIf
  EndSelect

  'now check to make sure primary stage is within range
  'this is the stage used to calculate flows
  If BadStgFlag = No Then 'if stage data is still good then...
    'lets check to see if within the expected range
    If (StagePrime > MaxExpStg) OR (StagePrime < MinExpStg) Then 'if out of range
      BadStgFlag = Yes 'set bad stage flag to true
      StagePrime = BadDataIndicator
      BadStgCount = BadStgCount + 1 'incriment bad stage counter
      '        StgLoop = 0 'initialize variable for Stg Filter below
    Else 'if stage is still good
      '        Call StgFilter 'call secondary stage filter
    EndIf
  Else 'if Bad Stage Flag was already true (from above code)
    BadStgCount = BadStgCount + 1 'incriment bad stage counter
    '      StgLoop = 0 'initialize variable for Stg Filter below
  EndIf
  'which stage insturment type being used will be stored in the output files
  StgSelect = SelStgPrime + ":" + SelStgSecnd 'indicates stage type being used
EndSub

Sub TrueStage
  'Now lets get correct offsets for each instrument to produce an accurate "Stage"
  If TrueUpBeamStg = BadDataIndicator AND TrueVMPressStg = BadDataIndicator AND TruePS1Stg = BadDataIndicator AND TruePS2Stg = BadDataIndicator AND TrueSondeStg = BadDataIndicator Then
    ExitSub
  EndIf
  If ((TrueUpBeamStg <> BadDataIndicator) AND (VMupBeam <> BadDataIndicator)) Then ' if user types in a reference stage for Upbeam then
    UpBeamOffset = TrueUpBeamStg-VMupBeam ' get offset for UpBeam
  EndIf 'Otherwise do nothing
  If ((TrueVMPressStg <> BadDataIndicator) AND (VMpressure <> BadDataIndicator)) Then 'if user types in a reference stage VM Pressure sensor then
    VMPressOffset = TrueVMPressStg-VMpressure 'get offset for VM pressure sensor
  EndIf 'otherwise do nothing
  If ((TruePS1Stg <> BadDataIndicator) AND (PsPress1Stg(1) <> BadDataIndicator)) Then 'if user types in a reference stage for Pressure sensor1 then
    PS1Offset = TruePS1Stg-PsPress1Stg(1) 'Get offset for pressure sensor 1
  EndIf 'Otherwise do nothing
  If ((TruePS2Stg <> BadDataIndicator) AND (PSpress2Stg(1) <> BadDataIndicator)) Then 'if user types in a reference stage for pressure sensor2 then
    PS2Offset = TruePS2Stg - PSpress2Stg(1)
  EndIf 'Otherwise do nothing
  #If WqSonde <> "NONE" Then
    If ((TrueSondeStg <> BadDataIndicator) AND (WqDepthFt <> BadDataIndicator)) Then 'if user types in a reference stage for YSI then
      SondeOffset = TrueSondeStg - WqDepthFt
    EndIf
  #EndIf
  'Otherwise do nothing
EndSub

'______________Stage Difference Routine________________________
'Used to produce a graph in RTMC to see the difference between stage values at a finer scale, indication of drifting
Sub StageDiff
  StgDiff = StagePrime - StageSecnd
  Round (StgDiff,3)
EndSub


'_____________________________________PsPressure Subroutine_______________________________
Sub GetPsPress
  Select Case PSPressPort
  Case 3
    SDI12Recorder (PsPress1Stg(),PS1Com3,PSPressAddr,"M!",1.0,0)
  Case 5
    SDI12Recorder (PsPress1Stg(),PS1Com5,PSPressAddr,"M!",1.0,0)
  EndSelect
  If PsPress1Stg(1) = NAN Then 'if no data commes in
    PSPressDataIn = No
  Else 'if there is PS Pressure data
    PSPressDataIn = Yes
  EndIf
EndSub

'__________________________________Pressure Sensor 2 Subroutine______________________________
Sub GetPSpress2
  Select Case PSpress2Port
  Case 3
    SDI12Recorder (PSpress2Stg(),PS2Com3,PSpress2Addr,"M!",1.0,0)
  Case 5
    SDI12Recorder (PSpress2Stg(),PS2Com5,PSpress2Addr,"M!",1.0,0)
  EndSelect
  If PSpress2Stg(1) = NAN Then 'if no data comes in
    PSpress2DataIn = No
  Else 'if there is Float Recorder data
    PSpress2DataIn = Yes
  EndIf
EndSub

'__________________________Get Instrument Serial Numbers_________________
Sub GetSN
  If (ModDay > 79270) AND (ModDay < 79390) AND RecCalibData = False Then 'if 2200hrs + 1-3 minutes and not Calbrating then get serial numbers of all
    AdcpSN = AdcpSN
    If AdcpSN <> InitialAdcpSN Then
      NewADCP = True
      InitialAdcpSN = AdcpSN 'set the new s/n to initial
    Else
      NewADCP = False
    EndIf
    Select Case PSPressPort
    Case 3
      SDI12Recorder (PS1SN,PS1Com3,PSPressAddr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
      If PS1SN <> InitialPS1SN Then
        NewPS1 = True
        InitialPS1SN = PS1SN 'Set the new sn to initial
      Else
        NewPS1 = False
      EndIf  'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
    Case 5
      SDI12Recorder (PS1SN,PS1Com5,PSPressAddr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
      If PS1SN <> InitialPS1SN Then
        NewPS1 = True
        InitialPS1SN = PS1SN 'Set the new sn to initial
      Else
        NewPS1 = False
      EndIf                                      'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
    EndSelect
    Select Case PSpress2Port
    Case 3
      SDI12Recorder (PS2SN,PS2Com3,PSpress2Addr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
      If PS2SN <> InitialPS2SN Then
        NewPS2 = True
        InitialPS2SN = PS2SN 'Set the new sn to initial
      Else
        NewPS2 = False
      EndIf                                     'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
    Case 5
      SDI12Recorder (PS2SN,PS2Com5,PSpress2Addr,"I!",1.0,0) '"I!" command gets brand, model, serial number, firmware, etc. from pressure sensors.
      If PS2SN <> InitialPS2SN Then
        NewPS2 = True
        InitialPS2SN = PS2SN 'Set the new sn to initial
      Else
        NewPS2 = False
      EndIf                                     'didn't parse the string to only retrieve S/N because it's useful to know the brand and model.
    EndSelect
  EndIf 'end if midnight
EndSub

'____________________________________Calculates interval for filter loops
Sub CalcLoopInterval
  Dim UnitMult As Float
  Select Case ScanUnit
  Case = 1
    UnitMult = 60000  'milliseconds in minute
  Case = 2
    UnitMult = 60     'seconds in minute
  Case = 3
    UnitMult = 1    'minutes in minute
  Case = 4
    UnitMult = 0.0166666666  'hours in minute (ok we'll probably never use this scan rate but just to be safe!!!!)
  Case = 5
    UnitMult = 0.0006944444  'days in minute (Only if we're measuring lake evaportation!!!!)
  EndSelect
  LoopInterval = (UnitMult/ScanRate) * 15 'number of scans in 15 minutes

  Select Case FastScanUnit
  Case = 1
    UnitMult = 60000  'milliseconds in minute
  Case = 2
    UnitMult = 60     'seconds in minute
  Case = 3
    UnitMult = 1    'minutes in minute
  Case = 4
    UnitMult = 0.0166666666  'hours in minute (ok we'll probably never use this scan rate but just to be safe!!!!)
  Case = 5
    UnitMult = 0.0006944444  'days in minute (Only if we're measuring lake evaportation!!!!)
  EndSelect
  FastLoopInterval = (UnitMult/FastScanRate) * 15 'number of scans in 15 minutes
EndSub

'______________________________Main Decoder___________________________________________________________
'Main Decoder for Workhorse PD0 file.  This Is run after incoming data has passed checks in main program scan.
'This decoder parses out the various data types and the varibles that are contained in the fixed header data type.
'The variable data types are decoded in separate subroutines and those subroutines are called from this subroutine.
Sub MainDecode
  Dim OffsetCounter As Long
  Dim TypeCounter As Long
  Dim IdCounter As Long
  'First decode PD0 header
  Datatypes = Longarray(6)
  Datatypes = Datatypes + 1 'Include the vertical data"
  OffsetCounter = 1
  'Get data offsets for each data type
  For TypeCounter = 1 To (Datatypes*2) Step 2
    LSB = Longarray(TypeCounter+6)
    MSB = Longarray(TypeCounter+7)
    Offsets(OffsetCounter)=(LSB + (MSB*256)) + 1
    OffsetCounter = OffsetCounter + 1
  Next TypeCounter
  'Get fixed leader offset
  FixedLeadOffset = Offsets(1)
  'Get variable leader offset
  VarLeadOffset = Offsets(2)
  'Now decode the fixed leader
  'get number of Beams
  NumBeams = Longarray(FixedLeadOffset + 8)
  'Get number of Bins
  NumADCPBins = Longarray(FixedLeadOffset + 9)
  If NumADCPBins >= MaxBins Then
    Numbins = MaxBins
  EndIf
  'Get Pings per Ensemble
  LSB = Longarray(FixedLeadOffset + 10)
  MSB = Longarray(FixedLeadOffset + 11)
  EnsPings = LSB + (MSB * 256)
  'Get Bin Size
  LSB = Longarray(FixedLeadOffset + 12)
  MSB = Longarray(FixedLeadOffset + 13)
  BinSize = LSB + (MSB * 256)
  'Get Blanking distance
  LSB = Longarray(FixedLeadOffset + 14)
  MSB = Longarray(FixedLeadOffset + 15)
  BlankDist = LSB + (MSB * 256)
  EX = Longarray(FixedLeadOffset + 25)
  If EX <= 7 Then
    Coord = "BEAM"
    Select Case NumBeams
    Case 2
      Decode = "Radial Velocities - V1=Beam1 V2=Beam2 disregard V3 and V4"
    Case 3
      Decode = "Radial Velocities - V1=Beam1 V2=Beam2 V3=Beam3 disregard V4"
    Case 4
      Decode = "Radial Velocities - V1=Beam1 V2=Beam2 V3=Beam3 V4=Beam4"
    Case Else
      Decode = "System could not be decoded"
    End Select
    RecordAll = true 'Beam coordinates are only used by special studies
    UseDir = false
  EndIf
  If (EX <= 15) AND (EX > 7) Then
    Coord = "INST"
    Select Case NumBeams
    Case 2
      Decode = "Instrument Coordinates - V1=X V2=Y disregard V3 and V4"
      BiRatOK = True 'sets flag indication that this is a channel master in instrument coordinates and it's ok to use a bi-directional rating if needed
    Case 3
      Decode = "Instrument Coordinates - V1=X V2=Y disregard V3 V4=Error"
      If IsVADCP = False Then
        BiRatOK = True 'It's ok to use the bi-rating if it is a 3-beam system and NOT an uplooker
      Else
        BiRatOK = False
      EndIf
    Case 4
      Decode = "Instrument Coordinates - V1=X V2=Y V3=Z and V4=Error"
      BiRatOK = False 'Don't allow use of bi-rating with uplookers.
    Case Else
      Decode = "System could not be decoded"
    End Select
    UseDir = false
  EndIf
  If (EX <= 23) AND (EX > 15) Then
    Coord = "SHIP"
    Select Case NumBeams
    Case 2
      Decode = "Error! --  Cannot set CM to ship coordinates"
    Case 3
      Decode = "Ship Coordinates - V1=Port V2=Starbord V3=Z and V4=Error"
    Case 4
      Decode = "Ship Coordinates - V1=Port V2=Starbord V3=Z and V4=Error"
    Case Else
      Decode = "System could not be decoded"
    End Select
    UseDir = false
  EndIf
  If (EX <= 31) AND (EX > 23) Then
    Coord = "EARTH"
    Select Case NumBeams
    Case 2
      Decode = "Error! --  Cannot set CM to Earth coordinates"
    Case 3
      Decode = "Earth Coordinates - V1=East V2=North V3=Z and V4=Error"
      RecordAll = true 'Special studies also uses earth coordinates
      UseDir = false
    Case 4
      Decode = "Earth Coordinates - V1=East V2=North V3=Z and V4=Error"
      RecordAll = true 'Special studies also uses earth coordinates
    Case Else
      Decode = "System could not be decoded"
    End Select
  EndIf
  'get instrument s/n
  ADCPSN01 = Longarray(FixedLeadOffset + 57)
  ADCPSN02 = Longarray(FixedLeadOffset + 56)
  ADCPSN03 = Longarray(FixedLeadOffset + 55)
  ADCPSN04 = Longarray(FixedLeadOffset + 54)
  AdcpSN = ADCPSN04 + (ADCPSN03*256) + (ADCPSN02*65536) +(ADCPSN01*16777216)
  '  TestADCPSN = ADCPSN04 + (ADCPSN03*256) + (ADCPSN02*65536) +(ADCPSN01*16777216)

  'get Variable Header Data
  Call VarLeadDecode
  'Loop through remaining data types, verify thier profile IDs and assign proper offsets'  Other data can be accomodated here if need be IE percent good etc
  'If profile IDs match the required data types, then call the appropriate decoders
  IsCM = No
  IsVADCP = No
  IsWorkhorse = No
  For IdCounter = 3 To Datatypes
    LSB = Longarray(Offsets(IdCounter))
    MSB = Longarray(Offsets(IdCounter) + 1)
    TempId = LSB + (MSB * 256)
    IDwords(IdCounter) = TempId
    Select Case TempId
    Case CorrelationProfileID
      'Ok it matches Correlation ID
      CorrDatOffset = Offsets(IdCounter)
      Call CorrelationDecode
    Case RSSIProfileID
      'OK it matches RSSI ID
      RSSIDatOffset = Offsets(IdCounter)
      Call RSSIDecode
    Case VelocityProfileID
      'OK it matches Velocity ID
      VelDatOffset = Offsets(IdCounter)
      Call VelDecode
    Case VMStageID
      'Ok it matches Surface track (vertical beam) Status ID
      VMStageDatOffset = Offsets(IdCounter)
      If NumBeams = 2 Then
        IsCM = Yes
      Else
        IsVADCP = Yes
        Call VADCPTransform
      EndIf
      Call VMStageDecode
    EndSelect
  Next IdCounter
  If (IsCM = No) AND (IsVADCP = No)
    If (NumBeams = 4) OR (NumBeams = 3) Then IsWorkhorse = Yes 'It's a 4 beamworkhorse or 3 beam Hadcp)
  EndIf
  'After calling all the decoders, Zero out the LongArray
  Erase (Longarray())
EndSub
'__________________________Variable Leader Decoder______________________________________
'This Sub decodes the variable leader from the longArray
Sub(VarLeadDecode)
  VarLeadOffset = VarLeadOffset - 1 'to line up with RDI Documentation
  'When you decode 2 byte binary data, you have to multiply the most significant byte
  'by 256
  LSB = 0
  MSB = 0
  temp = 0
  'get Ensemble Number
  LSB = Longarray(VarLeadOffset + 3)
  MSB = Longarray(VarLeadOffset + 4)
  MSB1 = Longarray(VarLeadOffset + 12)
  EnsembleNo = (65536 * MSB1) + (256 * MSB) + LSB
  'get Vm time
  VMYear = Longarray(VarLeadOffset + 5)
  VMMonth = Longarray(VarLeadOffset + 6)
  VMDay = Longarray(VarLeadOffset + 7)
  VMHour = Longarray(VarLeadOffset + 8)
  VMMinute = Longarray(VarLeadOffset + 9)
  VMSecond = Longarray(VarLeadOffset + 10)
  VMTime = VMYear + "/" + VMMonth + "/" + VMDay + " " + VMHour + ":" + VMMinute + ":" + VMSecond
  'get Buit in test results
  LSB = Longarray(VarLeadOffset + 13)
  MSB = Longarray(VarLeadOffset + 14)
  BIT = (256 * MSB) + LSB
  'get Heading
  LSB = Longarray(VarLeadOffset + 19)
  MSB = Longarray(VarLeadOffset + 20)
  VMHeading = ((256 * MSB) + LSB) * 0.01 'Heading scale factor
  'get Pitch
  LSB = Longarray(VarLeadOffset + 21)
  MSB = Longarray(VarLeadOffset + 22)
  temp = (256 * MSB) + LSB
  If temp > 32767 Then
    temp = temp - 65536
  EndIf
  VMpitch = temp * 0.01 'Pitch scale factor
  'get Roll
  LSB = Longarray(VarLeadOffset + 23)
  MSB = Longarray(VarLeadOffset + 24)
  temp = (256 * MSB) + LSB
  If temp > 32767 Then
    temp = temp - 65536
  EndIf
  VMroll = temp * 0.01 'Roll scale factor
  'Get Salinity
  LSB = Longarray(VarLeadOffset + 25)
  MSB = Longarray(VarLeadOffset + 26)
  temp = (256 * MSB) + LSB
  ES = temp
  'Get Temperature
  LSB = Longarray(VarLeadOffset + 27)
  MSB = Longarray(VarLeadOffset + 28)
  temp = (256 * MSB) + LSB
  If temp > 32767 Then
    temp = temp - 65536
  EndIf
  VMtempC = temp * 0.01 'Temperature scale factor
  VMtempF = VMtempC * 9/5 + 32
  'get WHvolts
  VMVolts = Longarray(VarLeadOffset + 36)

  'get pressure from Workhorse
  WHpressure = 0
  WHTempM = 0
  WHTempK = 0
  WHPSTemp = 0
  DepthLSB = 0
  DepthLSB1 = 0
  DepthMSB = 0
  DepthMSB1 = 0
  'Get corrected Max pressure (depth) from ensemble
  DepthLSB = Longarray(VarLeadOffset + 49)
  DepthLSB1 = Longarray(VarLeadOffset + 50)
  DepthMSB = Longarray(VarLeadOffset + 51)
  DepthMSB1 = Longarray(VarLeadOffset + 52)
  WHPSTemp = (16777216 * DepthMSB1) + (65536 * DepthMSB) + (256 * DepthLSB1) + DepthLSB 'this seems quite large, Better call RDI
  If WHPSTemp <> 0 Then
    WHTempK = WHPSTemp/100 'convert from decapascals to kpa
    WHTempM = (WHTempK * (1.02-0.00069*ES))/10
    WHpressure = WHTempM * Meters_to_Feet 'convert to feet
  Else
    WHpressure = BadDataIndicator
  EndIf
  ScanDiff = EnsembleNo - ScanNo
EndSub

'_______________Decode Correlation data and averages beams for each bin_________________
Sub(CorrelationDecode)
  'initialize output Arrays
  For Bin = 1 To MaxBins
    For Beam = 1 To MaxBeams
      ensCorr(Bin,Beam) = 0
    Next Beam
  Next Bin
  BinStep = 1
  EnsBin = 0
  CorrDatOffset = CorrDatOffset + 1 'to get past 2 byte ID
  For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
    nCorr = 0
    AccumCorr = 0
    temp = CorrDatOffset + (4 * EnsBin) 'jump down 4 bytes each bin
    EnsBin = EnsBin + BinStep
    For Beam = 1 To NumBeams 'only grab one byte each loop
      AccumCorr = AccumCorr + Longarray(temp + Beam)
      nCorr = nCorr + 1
      ensCorr(Bin,Beam) = Longarray(temp + Beam) 'could also average here
    Next Beam
    Select Case nCorr 'average beams for each bin
    Case 0
      AvgCorr(Bin)= 0
    Case 1
      AvgCorr(Bin) = AccumCorr
    Case 2 To 4
      AvgCorr(Bin) = AccumCorr / nCorr
    Case Else
      AvgCorr(Bin) = 0
    EndSelect
  Next Bin
  'Call CorrspikeAdd
EndSub

'_________Decode Backscattered Amplitude data and averages beams for each bin___________
Sub(RSSIDecode)
  'initialize output Arrays
  For Bin = 1 To MaxBins
    For Beam = 1 To MaxBeams
      ensRSSI(Bin,Beam) = 0
    Next Beam
  Next Bin
  BinStep = 1
  EnsBin = 0
  RSSIDatOffset = RSSIDatOffset + 1 'to get past 2 byte ID
  For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
    nRSSI = 0 'zero beamwise rssi counter
    AccumRSSI = 0 'zero beamwise rssi accumulator
    AvgRSSIAccum = 0 'zero binwise rssi accumulator
    AvgRSSIcounter = 0 'zero binwise rssi counter
    temp = RSSIDatOffset + (4 * EnsBin) 'jump down 4 bytes each bin
    EnsBin = EnsBin + BinStep
    For Beam = 1 To NumBeams 'only grab one byte each loop
      AccumRSSI = AccumRSSI + Longarray(temp + Beam)
      nRSSI = nRSSI + 1
      ensRSSI(Bin,Beam) = Longarray(temp + Beam) 'could also average here
    Next Beam
    Select Case nRSSI 'average beams for each bin
    Case 0
      AvgRSSI(Bin)= 0
    Case 1
      AvgRSSI(Bin) = AccumRSSI
    Case 2 To 4
      AvgRSSI(Bin) = AccumRSSI / nRSSI
    Case Else
      AvgRSSI(Bin) = 0
    EndSelect
  Next Bin
  'Call RSSIspikeAdd
  'calculate average RSSI from Swath of data (User Selected Bins)
  For Bin = AvgRSSIStartBin To AvgRSSIEndBin
    If AvgRSSI(Bin) <> 0 Then 'average the bins
      AvgRSSIAccum = AvgRSSIAccum + AvgRSSI(Bin)
      AvgRSSIcounter = AvgRSSIcounter + 1
    EndIf
  Next Bin
  If (AvgRSSIAccum <> 0) AND (AvgRSSIcounter <> 0) Then 'if either the accumulator is zero or the counter is zero then set avgrssi to bad
    AvgSwathRSSI = AvgRSSIAccum/AvgRSSIcounter
  Else
    AvgSwathRSSI = BadDataIndicator
  EndIf
EndSub

'_________________________________Channel Master Stage Decoder___________

Sub(VMStageDecode)
  If IsWorkhorse Then
    VMpressure = BadDataIndicator
    VMupBeam = BadDataIndicator
    Exit Sub
  EndIf
  VMStageDatOffset = VMStageDatOffset - 1 'to line up with RDI Documentation
  'When you decode 4 byte binary data, you have to multiply the most significant byte
  'by 16777216
  '--------------Debugging variables
  DepthLSB = 0
  DepthLSB1 = 0
  DepthMSB = 0
  DepthMSB1 = 0
  '---------------Debugging variables
  temp = 0
  TempM = 0
  LSBTemp = 0
  LSB1Temp = 0
  MSBTemp = 0
  MSB1Temp = 0
  '---------------------Get get corrected Surface track (depth) from ensemble
  DepthLSB = Longarray(VMStageDatOffset + 3)
  DepthLSB1 = Longarray(VMStageDatOffset + 4)
  DepthMSB = Longarray(VMStageDatOffset + 5)
  DepthMSB1 = Longarray(VMStageDatOffset + 6)
  VMTemp = (16777216 * DepthMSB1) + (65536 * DepthMSB) + (256 * DepthLSB1) + DepthLSB
  If VMTemp <> 0 Then
    TempM = VMTemp/10000
  Else
    TempM = BadDataIndicator
  EndIf
  VMupBeam = TempM 'This is the range to the surface from the upward beam
  '-----------------------------------------------------get uncorrected depth
  LSBTemp = Longarray(VMStageDatOffset + 7)
  LSB1Temp = Longarray(VMStageDatOffset + 8)
  MSBTemp = Longarray(VMStageDatOffset + 9)
  MSB1Temp = Longarray(VMStageDatOffset + 10)
  '    RawDepth = (16777216 * MSB1Temp) + (65536 * MSBTemp) + (256 * LSB1Temp) + LSBTemp
  '----------------Get Signal Amplitude at Surface
  LSBTemp = Longarray(VMStageDatOffset + 12)
  '    DepthSig = LSBTemp
  '--------------------------------Get Percent Good of Surface Track
  LSBTemp = Longarray(VMStageDatOffset + 13)
  '    PercGoodSurface = LSBTemp
  LSB = 0
  L1SB = 0
  MSB = 0
  M1SB = 0
  temp = 0
  TempM = 0
  'Get corrected Max pressure (depth) from ensemble
  LSB = Longarray(VMStageDatOffset + 43)
  L1SB = Longarray(VMStageDatOffset + 44)
  MSB = Longarray(VMStageDatOffset + 45)
  M1SB = Longarray(VMStageDatOffset + 46)
  VMPSTemp = (16777216 * M1SB) + (65536 * MSB) + (256 * L1SB) + LSB 'this seems quite large, Better call RDI
  If VMPSTemp <> 0 Then
    TempM = VMPSTemp/10000
  Else
    TempM = BadDataIndicator
  EndIf
  VMpressure = TempM
  VMupBeam = VMupBeam * Meters_to_Feet 'convert to Feet
  VMpressure = VMpressure * Meters_to_Feet 'convert to Feet
EndSub

'________________________________Velocity Decoder_______________________________________
Sub(VelDecode)
  'initialize output Arrays
  If FlowSign = 0 Then FlowSign = 1
  For Bin = 1 To MaxBins
    For Beam = 1 To MaxBeams
      ensVelocity(Bin,Beam) = NAN
    Next Beam
    V1(Bin) = NAN
    V2(Bin) = NAN
    V3(Bin) = NAN
    V4(Bin) = NAN
    V1Disable(Bin) = False
    V2Disable(Bin) = False
    V3Disable(Bin) = False
    V4disable(Bin) = False
  Next Bin
  BinStep = 1
  EnsBin = 0
  For Bin = 1 To Numbins 'Start at Bin 1 Beam 1
    temp = VelDatOffset + 8 * EnsBin 'jump down 8 bytes each bin
    EnsBin = EnsBin + BinStep
    For Beam = 1 To NumBeams
      Index = temp + 2 * Beam 'index down Two bytes each beam
      LSB = Longarray(Index)
      MSB = Longarray(Index + 1)
      BinVel = (256 * MSB) + LSB
      If BinVel = 32768 Then
        ensVelocity(Bin, Beam) = NAN 'bad data
      Else
        If BinVel > 32767 Then 'Handle twos compliment (negative velocity)
          BinVel = BinVel - 65536
          If BinVel < -32767 Then 'smallest allowable velocity
            BinVel = NAN 'bad data
          Else 'apply flow sign
            BinVel = BinVel * VelocityScaleWater
            BinVel = BinVel * FlowSign
          EndIf
          ensVelocity(Bin,Beam) = BinVel
        Else
          If BinVel > 32767 Then 'largest allowable velocity
            BinVel = NAN
          Else 'apply flow sign
            BinVel = BinVel * VelocityScaleWater
            BinVel = BinVel * FlowSign
          EndIf
          ensVelocity(Bin,Beam) = BinVel
        EndIf
      EndIf
    Next Beam
    'uplooker will use Zvel and Evel
    V1(Bin) = ensVelocity(Bin,1) 'Separate the big array into sub arrays
    If V1(Bin) = NAN Then V1Disable(Bin) = True 'disable the median or average calc
    V2(Bin) = ensVelocity(Bin,2) 'Could also use a small temp array for 'ensVelocity()
    If V2(Bin) = NAN Then V2Disable(Bin) = True 'disable the median or average calc
    V3(Bin) = ensVelocity(Bin,3)
    If V3(Bin) = NAN Then V3Disable(Bin) = True 'disable the median or average calc
    V4(Bin) = ensVelocity(Bin,4)
    If V4(Bin) = NAN Then V4disable(Bin) = True 'disable the median or average calc
  Next Bin
EndSub
#If UseAutoRange = true Then
  Sub CalcRangeBin
    'Dim Range As Float
    Dim DucerDepth As Float 'this is in FT
    Dim Sensordepth As Float 'this is in FT
    Dim DucerDepthCM As Float 'convert ducer depth to Centimeters
    'calculate range to water surface and set endbin appropriately
    ' Const UPbeam = 1
    ' Const VMpress = 2
    ' Const PSpress = 3
    ' Const PSpress2 = 4
    ' Const WqPress = 5
    Select Case RangeSource
    Case UPbeam
      Sensordepth = VMupBeam
    Case VMpress
      Sensordepth = VMpress
    Case PSpress
      Sensordepth = PsPress1Stg(1)
    Case PSpress2
      Sensordepth = PSpress2Stg(1)
    Case WqPress
      Sensordepth = WqDepthFt
    End Select
    DucerDepth = Sensordepth + DucerDepthOffset
    DucerDepthCM = DucerDepth * 30.48
    RangedBin = (FIX((DucerDepthCM - BlankDist)/BinSize))-CutOffBins 'remove user selected number of bins (based on beamchecks)
  End Sub
#EndIf

'________________________________Last Good Bin Filter_______________________________________
' Check the validity of bin data based on user defined thresholds
'Sub CalcLastGoodBin 'must call RSSIDecode and CorrelationDecode before calling this subroutine
'  LastGoodBin = 0
'  cntBin = 0
'  cntBin2 = 0
'  Beam = 0
'  Dim P As Long 'counter for tempcorr
'  For cntBin = 1 To NumBins
'    'zero the TempCorr array
'    For P = 1 To 4
'      TempCorr(P) = 0
'    Next P
'    For Beam = 1 To NumBeams
'      'put each beam corr into TempCorr array
'      TempCorr(Beam) = ensCorr(cntBin,Beam)
'    Next Beam
'    'now run swath std on the temp array
'    StdDevSpa (StdDevCorr(cntBin),4,TempCorr(1))'see parameter list help for StdDevSpa
'  Next cntBin
'
'  'Runs a series of checks for bin validity, based on user defined thresholds
'  For cntBin = 3 To NumBins 'starts test between bin 3 and bin 2; assumes bin 1 is good b/c sometimes bin 1 spikes
'    Select Case SelectFilter
'    Case = 0
'      ExitSub
'    Case = 1
'      If (AvgRSSI(cntBin) > (AvgRSSI(cntBin - 1)) + RSSIThreshold) Then
'        LastGoodBin = cntBin - 1
'        ExitSub
'      ElseIf cntBin = NumBins Then
'        For cntBin2 = 3 To NumBins
'          If ((AvgCorr(cntBin2) <= (AvgCorr(cntBin2-1)) - CorrThreshold)) OR ((AvgCorr(cntBin2) >= (AvgCorr(cntBin2-1)) + CorrThreshold))  Then
'            LastGoodBin = cntBin2 - 1
'            ExitSub
'          EndIf
'        Next
'      ElseIf cntBin2 = NumBins Then
'        LastGoodBin = cntBin2
'      EndIf
'    EndSelect
'  Next
'EndSub

'_______________________________Last Good Bin Check_____________________________________
'Checks to see is the LastGoodBin for the last 15 timestamps is within
' +/- 1 of the running average of the LastGoodBin.  If current LastGoodBin falls
'outside of accepted range then a counter is tripped.  This will test the overall effectiveness
'of thresholds for CalcLastGoodBin subroutine.  At a later date can add ability to filter
'out the bad ensembles.
'Sub LastGoodBinCheck
'  TestEns = LastGoodBin
'  '  If IfTime (0,15,Min) Then RunEnsSpikes = 0 'resets every 15 minutes
'  If RunEnsSpikes = 5 Then EnsLoop = 0 'resets EnsLoop if too many spikes encounter in 15 minutes
'  If EnsLoop < LoopInterval Then 'waits for 15 Minutes before preceeding with checks
'    EnsLoop = EnsLoop + 1
'  ElseIf TestEns < (AvgRunEns - 1) OR TestEns > (AvgRunEns + 1) Then
'    BadEnsFlag = True
'    BadEnsCount = BadEnsCount + 1
'    RunEnsSpikes = RunEnsSpikes + 1
'  Else
'    BadEnsFlag = False
'  EndIf
'  If BadEnsFlag = False Then AvgRun(AvgRunEns,1,TestEns,15) 'creates a 15 muinute running average of the LastGoodBin values
'EndSub

'____________________________1 Minute Velocity Average__________________________________
'subroutine averages all good bins for each ensemble for V1,V2, V3,and V4
'Min and Max acceptable Vel ranges are set by user with keypad
'defaults values are -5 and 5 respectively
Sub(OneMinuteCalcs)
  Dim TotBins As Long
  Dim BinVelCount As Long
  Public MidBin As Long
  Public EbbDir As Boolean = true
  ' If IfTime (0,1440,Min) Then BadVelCount = 0 'initialize counter
  V1Cnt = 0
  V1EbbCnt = 0
  V1FldCnt = 0
  V2Cnt = 0
  V2EbbCnt = 0
  V2FldCnt = 0
  V3Cnt = 0
  V4Cnt = 0
  V1Sum = 0
  V1EbbSum = 0
  V1FldSum = 0
  V2Sum = 0
  V2EbbSum = 0
  V2FldSum = 0
  V3Sum = 0
  V4Sum = 0
  IndexVel = 0
  For BinVelCount = 1 To MaxBins
    VMBinVel(BinVelCount) = NAN
    VmBinVelDisable(BinVelCount) = False
  Next BinVelCount
  VelCount = 0 'Zero out VelCount variable
  '  If UseAutoLastBin = True Then
  '    EndBin = LastGoodBin
  '  EndIf
  If (BiRatOK = True) AND (BiRating = True) Then 'Ok the user wants a bi-directional rating and we are using a channel master (instrument coordinates)
    UseBiRat = True 'we can do it
  Else
    UseBiRat = False'we can't do it (or user doesn't want it
  EndIf
  TotBins = EndBin - StartBin
  'lets deterimine flow dir from V1 just in case we are using bi-rating
  MidBin = TotBins/2
  If V1(MidBin) > BiRatTran Then 'Calculate flow direction (CM) if using Ebb/Flood rating (only used for CM with Instrument velocities)
    EbbDir = true 'flow is positive
  Else
    EbbDir = false 'flow is negative
  EndIf
  For Cnt = StartBin To EndBin
    If (V1(Cnt) <> NAN) AND (V1(Cnt)>= MinExpVel) AND (V1(Cnt)<= MaxExpVel) 'its probably good
      V1Sum = V1Sum + V1(Cnt)
      V1Cnt = V1Cnt + 1
      If UseBiRat = true Then 'Ok we have a bi-directional rating
        If EbbDir Then 'flow is positive (ebb) use the EBB bins
          'Calc Ebb bin sum here
          If (Cnt >= StartEbbBin) AND (Cnt <= EndEbbBin) Then 'let's do this bin
            V1EbbSum += V1(Cnt)
            V1EbbCnt += 1
          EndIf 'if it's in range
        Else 'Ok it's Flood direction (negative)
          'Calc Fld bin sum here
          If (Cnt >= StartFldBin) AND (Cnt <= EndFldBin)Then 'lets do this one
            V1FldSum += V1(Cnt)
            V1FldCnt += 1
          EndIf 'if it's in-range
        EndIf 'direction
      EndIf 'if Birating
    Else
      BadBinCnt = BadBinCnt + 1
      V1(Cnt) = BadDataIndicator
    EndIf
  Next
  If V1Sum <> 0 Then
    V1AVG = V1Sum/V1Cnt 'Calculate normal V1
  Else
    V1AVG = 0
  EndIf
  If V1EbbSum <> 0 Then
    V1EbbAvg = V1EbbSum/V1EbbCnt 'Calculate Bi-rating Ebb bin average
  Else
    V1EbbAvg = 0
  EndIf
  If V1FldSum <> 0 Then
    V1FldAvg = V1FldSum/V1FldCnt 'Calculate Bi-rating Flood bin average
  Else
    V1FldAvg = 0
  EndIf
  For Cnt = StartBin To EndBin 'OK, in case we are using both X(V1) and Y(V2) velocities to calculate iVel then we have to calc V2 averages
    If (V2(Cnt) <> NAN) AND (V2(Cnt)>= MinExpVel) AND (V2(Cnt)<= MaxExpVel)
      V2Sum = V2Sum +  V2(Cnt) 'Calculate normal V2
      V2Cnt = V2Cnt + 1
      If UseBiRat = true Then 'Ok we have a bi-directional rating
        If EbbDir Then
          'Calc Ebb bin sum here
          If (Cnt >= StartEbbBin) AND (Cnt <= EndEbbBin) Then 'let's do this bin
            V2EbbSum += V2(Cnt)
            V2EbbCnt += 1
          EndIf 'if it's in range
        Else 'Ok it's Flood direction
          'Calc Fld bin sum here
          If (Cnt >= StartFldBin) AND (Cnt <= EndFldBin)Then 'ok let's do this bin
            V2FldSum += V2(Cnt)
            V2FldCnt += 1
          EndIf 'if it's in-range
        EndIf 'direction
      EndIf 'if Birating
    Else
      BadBinCnt = BadBinCnt + 1
      V2(Cnt) = BadDataIndicator
    EndIf
  Next
  If V2Sum <> 0 Then
    V2AVG =  V2Sum/V2Cnt 'Calculate normal V2
  Else
    V2AVG = 0
  EndIf
  If V2EbbSum <> 0 Then
    V2EbbAvg = V2EbbSum/V2EbbCnt 'Calculate Bi-rating Ebb bin average (V2)
  Else
    V2EbbAvg = 0
  EndIf
  If V2FldSum <> 0 Then
    V2FldAvg = V2FldSum/V2FldCnt  'Calculate Bi-rating Flood bin average (V2)
  Else
    V2FldAvg = 0
  EndIf
  For Cnt = StartBin To EndBin
    If (V3(Cnt) <> NAN) AND (V3(Cnt)>= MinExpVel) AND (V3(Cnt)<= MaxExpVel)
      V3Sum = V3Sum +  V3(Cnt)
      V3Cnt = V3Cnt + 1
    Else
      BadBinCnt = BadBinCnt + 1
      V3(Cnt) = BadDataIndicator
    EndIf
  Next
  If V3Sum <> 0 Then
    V3AVG =  V3Sum/V3Cnt
  Else
    V3AVG = 0
  EndIf
  For Cnt = StartBin To EndBin
    If (V4(Cnt) <> NAN) AND (V4(Cnt)>= MinExpVel) AND (V4(Cnt)<= MaxExpVel)
      V4Sum = V4Sum +  V4(Cnt)
      V4Cnt = V4Cnt + 1
    Else
      BadBinCnt = BadBinCnt + 1
      V4(Cnt) = BadDataIndicator
    EndIf
  Next
  If V4Sum <> 0 Then
    V4AVG =  V4Sum/V4Cnt
  Else
    V4AVG = 0
  EndIf

  If UseV2 = Yes Then
    If BiRating Then 'calculate proper direction
      If EbbDir Then
        IndexVel = SQR(V1EbbAvg^2 + V2EbbAvg^2) 'pos flow
      Else
        IndexVel = SQR(V1FldAvg^2 + V2FldAvg^2) 'neg flow
      EndIf
    Else
      IndexVel = SQR(V1AVG^2 + V2AVG^2)'reg calc
    EndIf 'birating = true
    For Cnt = 1 To MaxBins
      If (V1(Cnt)<> BadDataIndicator) AND (V2(Cnt)<> BadDataIndicator) Then
        VMBinVel(Cnt) = SQR (V1(Cnt)^2 + V2(Cnt)^2)
        If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
          VelCount = VelCount + 1
        EndIf
      Else
        VMBinVel(Cnt) = BadDataIndicator
        VmBinVelDisable(Cnt) = True
      EndIf
    Next
  ElseIf UseDir = Yes Then
    IndexVel = (V1AVG * SIN(DegToRad * PosFlowDir)) + (V2AVG * COS(DegToRad * PosFlowDir))
    For Cnt = 1 To MaxBins
      If (V1(Cnt)<> BadDataIndicator) AND (V2(Cnt)<> BadDataIndicator) Then
        VMBinVel(Cnt) = (V1 * SIN(DegToRad * PosFlowDir)) + (V2 * COS(DegToRad * PosFlowDir))
        If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
          VelCount = VelCount + 1
        EndIf
      Else
        VMBinVel(Cnt) = BadDataIndicator
        VmBinVelDisable(Cnt) = True
      EndIf
    Next
  Else 'just normal computation using V1
    If BiRating Then 'we're using Ebb and Flood
      If EbbDir Then
        IndexVel = V1EbbAvg
      Else 'if flood
        IndexVel = V1FldAvg
      EndIf
    Else 'bi-rating is false
      IndexVel = V1AVG
    EndIf
    For Cnt = 1 To MaxBins
      If V1(Cnt) <> BadDataIndicator Then
        VMBinVel(Cnt) = V1(Cnt)
        If ((Cnt >= StartBin) AND (Cnt <= EndBin)) Then
          VelCount = VelCount + 1
        EndIf
      Else
        VMBinVel(Cnt) = BadDataIndicator
        VmBinVelDisable(Cnt) = True
      EndIf
    Next
  EndIf
  If VelCount >=  EndBin - StartBin Then 'if VelCount < EndBin, then must have been some bad bins (allow one missing bin)
    BadVelFlag = No 'initialize flag to false again
    Call VelFilter 'call velocity filter
  Else 'if VelCount isn't close to number of bins, then
    BadVelFlag = Yes 'set flag to true
    IndexVel = BadDataIndicator
    BadVelCount = BadVelCount + 1
    '  VelLoop = 0 'initialize variable for Vel Filter below
  EndIf
  'now lets count the bad velocity bins to keep track of them
  BadBinCount = (((EndBin+1)-StartBin)- VelCount)
  'check for above and below rating for more than 60 readings if below 60 readings then reset flag
  If ((IndexVel<>BadVel) AND (IndexVel<LowRatVel)) Then 'Ok we are below the rating
    LowCount = LowCount + 1
  ElseIf ((IndexVel<>BadVel) AND (IndexVel>HighRatVel)) Then 'Ok we a above the rating
    HighCount = HighCount + 1
  Else
    If HighCount > 0 Then HighCount = HighCount - 1
    If LowCount > 0 Then LowCount = LowCount - 1
  EndIf
  If HighCount > 60 Then HighMeas = true
  If LowCount > 60 Then LowMeas = true
  'Call VelspikeAdd
EndSub

'___________________Reseting High/Low Measurement Flags___________________
'This code is used to resent the high/low measurement flags when someone changes the "HighRatVel" or "LowRatVel",
'indicating that someone has been out to measure during those velocities.
Sub ResetMeasFlags
  If HighRatVel <> InitialHRV Then 'if user changes upper velocity rating value
    InitialHRV = HighRatVel 'make "initial" equal to the new value
    HighMeas = False 'reset high flow measurment needed indicator to false
    HighCount = 0 'reset number of times high flow (above rated) occurs to 0
  EndIf
  If LowRatVel <> InitialLRV Then 'if user changes lower velocity rating value
    InitialLRV = LowRatVel 'make "initial" equal to the new value
    LowMeas = False 'reset low flow measurement needed indicator to false
    LowCount = 0 'reset number of times low flow occurs (below rated) to 0
  EndIf
EndSub

'_________________________________Velocity Filter_________________________________________
Sub VelFilter
  If IndexVel <> 0 OR BadDataIndicator Then 'if there is data, then probably good to go...
    If (IndexVel >= MinExpVel) AND (IndexVel <= MaxExpVel) Then 'if  Vel is in range, then
      BadVelFlag = False 'We have valid data but maybe it's a spike
    Else 'if vel not in range...
      BadVelFlag = Yes
      BadVelCount = BadVelCount + 1
      IndexVel = BadDataIndicator
      ExitSub 'dont pass out of range data through filter
    EndIf
  Else 'otherwise, if no data in buffer, or serial error then
    DataErr = DataErr + 1
    BadVelFlag = Yes
    BadVelCount = BadVelCount + 1
    IndexVel = BadDataIndicator
    ExitSub 'don't pass bad data through filter
  EndIf
EndSub

Sub VADCPTransform 'reverse the V1 and V2 components because the brilliant RDI guys have them reversed on the VADCP
  If IsVADCP = Yes Then
    Dim TempV1(MaxBins) As Float
    Dim TempV1Disable(MaxBins) As Boolean
    Dim TempV2(MaxBins) As Float
    Dim TempV2Disable(MaxBins) As Boolean
    Dim TempCounter As Long
    For TempCounter = 1 To MaxBins
      TempV2(TempCounter) = V1(TempCounter) 'copy them out
      tempV2disable(TempCounter) = V1Disable(TempCounter) 'have to switch out the disable booleans also
      TempV1(TempCounter) = V2(TempCounter)
      TempV1disable(TempCounter) = V2Disable(TempCounter)
      V2(TempCounter) = TempV2(TempCounter) 'put them back in the opposite array
      V2Disable(TempCounter) = TempV2disable(TempCounter)
      V1(TempCounter) = TempV1(TempCounter)
      V1Disable(TempCounter) = TempV1disable(TempCounter)
      'V1 should now be X velocity and V2, Y velocity when using a VADCP
    Next TempCounter
  EndIf
EndSub
Function Ftime (TimeIn As String * 25) As String * 25 'converts datalogger time string into MM/DD/YYYY HH:MM:SS
  'RawTime = Public.Timestamp

  SplitStr (FSplitTime(),TimeIn," ",6,0)
  Dim SendMonth As String
  Dim SendDay As String
  Dim SendHour As String
  Dim SendMin As String
  Dim SendSec As String
  Dim SendYear As String

  If FSplitTime(1) < 10 Then
    SendMonth = "0" + FSplitTime(1)
  Else
    SendMonth = FSplitTime(1)
  EndIf
  If FSplitTime(2) < 10 Then
    SendDay = "0" + FSplitTime(2)
  Else
    SendDay = FSplitTime(2)
  EndIf
  If FSplitTime(4) < 10 Then
    SendHour = "0" + FSplitTime(4)
  Else
    SendHour = FSplitTime(4)
  EndIf
  If FSplitTime(5) < 10 Then
    SendMin = "0" + FSplitTime(5)
  Else
    SendMin = FSplitTime(5)
  EndIf

  If Round(FSplitTime(6),0) < 10 Then
    SendSec = "0" + Round(FSplitTime(6),0)
  Else
    SendSec = Round(FSplitTime(6),0)
  EndIf
  SendYear = Right(FSplitTime(3),4)
  ftime = SendMonth + "/" + SendDay + "/" + SendYear + " " + SendHour + ":" + SendMin + ":" + SendSec
End Function
#If HasVM Then
  Sub CheckSpikes 'change name later
    'check the RSSI, Correlation, and velocity queues against incoming data for spikes.  Queues must be full before call
    'Outputs the spike data to a file on the Card.
    Dim BinCount As Long
    Dim BeamCount As Long
    Dim TimeOut As String * 25
    Dim RSSIStd As Float
    Dim RSSIAvg As Float
    Dim CorrStd As Float
    Dim CorrAvg As Float
    Dim VelStd As Float
    Dim DataLine As String * 500
    Dim velAvg As Float
    Dim Top As Float = 0
    Dim Bottom As Float = 0
    Dim QueueCorrSpikes As Long = 0
    Dim QueueRSSISpikes As Long = 0
    Dim QueueVelSpikes As Long = 0
    Dim RSSITemp(16) As Float
    Dim CorrTemp(16) As Float
    Dim VelTemp(16) As Float
    #If SeeAllVel = True Then
      Public Binspikes(30) As Long
      Public BinResults(2) As Long
    #Else
      Dim Binspikes(30) As Long
      Public BinResults(2) As Long
    #EndIf
    Dim n As Long
    'Dim QueueTotalSpikes As Long = 0
    Dim QueueAvgStage As Float = 0
    Dim QueueVel As Float = 0
    'Dim QueueAvgVel As Float = 0
    If InStr(1,Status.CardStatus,"No Card",2) = 0 Then 'if the cards not there no point in checking spikes
      SpikeFileName = "CRD:VmSpikes-" & SiteID & ".csv"
      FileHandle = FileOpen (SpikeFileName,"a+b",-1)'open the spike file here
      If SendHeader Then
        '---------------commented out for spike test
        'FileHeader = "Spike: ," & "Timestamp" & "," & "Type" & "," & "Value" & "," & "Bin" & "," & "Beam" & "," & "STD last 15" & "," & "Mean last 15" & "," & "Threshold (n*std)" & "," & "Ivel" & "," & "StagePrime"
        'write file header, otherwise just write to file below
        'FileWrite (FileHandle, FileHeader & CHR(13) & CHR(10),0)
        'DataLine = "Stats: ," & TimeOut & "," & "Ivel = " & IVel & "," & "StageAvg = " & QueueAvgStage & "," & "CorrSpikes = " & QueueCorrSpikes & "," & "RSSI Spikes = " & QueueRSSISpikes & "," & "Vel Spikes = " & QueueVelSpikes & "," & "DQI = " & QueueDQI
        'FileHeader = "Stats: ," & "Timestamp" & "," & "Ive" & "," & "Stage Avg" & "," & "Corr spikes" & "," & "RSSI Spikes" & "," & "Vel Spikes" & "," & "DQI = " & QueueDQI
        '-----------------------------------------------
        FileHeader = "Type," & "Timestamp," & "NumBeams," & "NumBins," & "StartBin,"& "EndBin,"& "BinSize," & "Ivel," & "Stage Avg,"& "Corr spikes," & "RSSI Spikes," & "Vel Spikes," & "DQI," & ">1 spikes," & "Bin"
        FileWrite (FileHandle, FileHeader & CHR(13) & CHR(10),0)
        SendHeader = False
      EndIf
      QueueCorrSpikes = 0
      QueueRSSISpikes = 0
      QueueVelSpikes = 0
      QueueAvgStage = 0
      QueueDQI = 0
      QueueVel = 0
      Erase Binspikes()
      ' Dim SampleCount As Long
      'should use startbin to endbin to eliminate unwanted spikes
      For BinCount = StartBin To EndBin
        For BeamCount = 1 To NumBeams
          Erase RSSITemp()
          Erase VelTemp()
          Erase CorrTemp()
          For n = 1 To 16
            RSSITemp(n) = RSSIspike(BinCount,BeamCount,n)
            Veltemp(n) = Velspike(BinCount,BeamCount,n)
            CorrTemp(n)= Corrspike(BinCount,BeamCount,n)
          Next n
          'StdDevSpa(RSSIStd,15,RSSIspike(BinCount,BeamCount,1) 'compute standard deviation of RSSI Queue
          StdDevSpa(RSSIStd,15,rssitemp(1))
          If RSSIStd = 0 Then RSSIStd = 0.1 'set to minimum if zero
          'AvgSpa(RSSIAvg,15,RSSIspike(BinCount,BeamCount,1)
          AvgSpa(RSSIAvg,15,RSSITemp(1))
          Top = RSSIAvg + (RSSIStd * RSSIStdNo)
          Bottom = RSSIAvg - (RSSIStd * RSSIStdNo)
          If (ensRSSI(BinCount,BeamCount) < Bottom) OR (ensRSSI(BinCount,BeamCount) > Top) Then
            SpikeCounter = SpikeCounter + 1
            Binspikes(BinCount) = Binspikes(BinCount) + 1
            QueueRSSISpikes = QueueRSSISpikes + 1
            TimeOut = Ftime(Public.Timestamp)
            TestTime = TimeOut
            'commented out for spike test-----------------------------------------
            'DataLine = "Spike: ," & TimeOut & "," & "RSSI" & "," & ensRSSI(BinCount,BeamCount) & "," & BinCount & "," & BeamCount & "," & Round(RSSIStd,2) & "," & Round(RSSIAvg,2) & "," & RSSIStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
            'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
          EndIf
          'StdDevSpa(CorrStd,15,Corrspike(BinCount,BeamCount,1) 'compute standard deviation of Correlation Queue
          StdDevSpa(CorrStd,15,corrtemp(1))
          If CorrStd = 0 Then CorrStd = 0.1 'set to minimum if zero
          'AvgSpa(CorrAvg,15,Corrspike(BinCount,BeamCount,1)
          AvgSpa(CorrAvg,15,CorrTemp(1))
          Top = CorrAvg + (CorrStd * CorrStdNo)
          Bottom = CorrAvg - (CorrStd * CorrStdNo)
          If (ensCorr(BinCount,BeamCount) < Bottom) OR (ensCorr(BinCount,BeamCount) > Top) Then
            SpikeCounter = SpikeCounter + 1
            Binspikes(BinCount) = Binspikes(BinCount) + 1
            QueueCorrSpikes = QueueCorrSpikes + 1
            TimeOut = Ftime(Public.Timestamp)
            'commented out for spike test----------------------------------------
            'DataLine = "Spike: ," & TimeOut & "," & "Corr" & "," & ensCorr(BinCount,BeamCount) & "," & BinCount & "," & BeamCount & "," & Round(CorrStd,2) & "," & Round(CorrAvg,2) & "," & CorrStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
            'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
          EndIf
          StdDevSpa(VelStd,15,veltemp(1))
          If VelStd = 0 Then VelStd = .1
          'AvgSpa(velAvg,15,Velspike(BinCount,BeamCount,1) 'Velocity average for Queue
          AvgSpa(velAvg,15,veltemp(1))
          Top = velAvg + (VelStd * VelStdNo)
          Bottom = velAvg - (VelStd * VelStdNo)
          If (ensVelocity(BinCount,BeamCount) < Bottom) OR (ensVelocity(BinCount,BeamCount) > Top) Then
            'for future use, we can set the disable variables here, but we need to call this before calling the velocity output table
            SpikeCounter = SpikeCounter + 1
            Binspikes(BinCount) = Binspikes(BinCount) + 1
            QueueVelSpikes = QueueVelSpikes + 1
            TimeOut = Ftime(Public.Timestamp)
            'commented out for spike test------------------------------------------------
            'DataLine = "Spike: ," & TimeOut & "," & "Velocity" & "," & Round(ensVelocity(BinCount,BeamCount),2) & "," & BinCount & "," & BeamCount & "," & Round(VelStd,2) & "," & Round(velAvg,2) & "," & VelStdNo & "," & Round(iVel,3) & "," & Round(StagePrime,2)
            'FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
          EndIf
          'StdDevSpa(VelStd,15,Velspike(BinCount,BeamCount,1) 'compute standard deviation of Velocity Queue

          'need to output Velocity average here every 15 mins regardless of spikes to provide a velocity scale for visualization
        Next BeamCount
      Next BinCount
      QueueDQI = (QueueCorrSpikes + QueueRSSISpikes + QueueVelSpikes)/15 'number of ensembles per period
      QueueDQI = Round(QueueDQI,2)
      velAvg = Round(velAvg,2)
      AvgSpa(QueueAvgStage,15,StageSpike(1)
      QueueAvgStage = Round(QueueAvgStage,2)
      QueueVel = Round(IndexVel,2)
      TimeOut = Ftime(Public.Timestamp)
      MaxSpa(BinResults(),30,Binspikes())
      If BinResults(1) < 2 Then
        BinResults(1) = 0
        BinResults(2) = 0
      EndIf
      'DataLine = "Stats: ," & TimeOut & "," & velAvg & "," & QueueAvgStage & "," & QueueCorrSpikes & "," & QueueRSSISpikes & "," & QueueVelSpikes & "," & QueueDQI
      DataLine = "Stats: ," & TimeOut & "," & NumBeams & "," & Numbins & "," & StartBin & "," & EndBin & "," & BinSize & ","& QueueVel & "," & QueueAvgStage & "," & QueueCorrSpikes & "," & QueueRSSISpikes & "," & QueueVelSpikes & "," & QueueDQI & "," & BinResults(1) & "," & BinResults(2)
      FileWrite (FileHandle,DataLine & CHR(13) & CHR(10),0)
      FileClose(FileHandle)
    EndIf
    CardError = Status.CardStatus
  End Sub

#EndIf 'if hasvm
'----------------------------------------------------------------------------
'add spikes to correlation,RSSI and Velocity fifo Queues and advance to next queue position. Note: call after checkspikes
'---------------------------------------Sub AddSpikes-------------------------------------------------------------------
#If HasVM Then
  Sub AddSpikes
    Dim BinCount As Long
    Dim BeamCount As Long
    Dim SampleCount As Long
    If BadVelFlag Then Exit Sub
    For BinCount = 1 To Numbins 'get all bins for storage
      For BeamCount = 1 To NumBeams
        Corrspike(BinCount,BeamCount,16) = ensCorr(BinCount,BeamCount) 'add new to end
        RSSIspike(BinCount,BeamCount,16) = ensRSSI(BinCount,BeamCount) 'add new to end
        Velspike(BinCount,BeamCount,16) = ensVelocity(BinCount,BeamCount) 'add new to end
        For SampleCount = 1 To 15
          'Jack out first and copy in last
          Corrspike(BinCount,BeamCount,SampleCount) = Corrspike(BinCount,BeamCount,SampleCount + 1)
          RSSIspike(BinCount,BeamCount,SampleCount)=RSSIspike(BinCount,BeamCount,SampleCount + 1)
          Velspike(BinCount,BeamCount,SampleCount) = Velspike(BinCount,BeamCount,SampleCount + 1)
        Next SampleCount
      Next BeamCount
    Next BinCount
    'add stage to stagespike queue
    StageSpike(16) = StagePrime
    For SampleCount = 1 To 15
      StageSpike(SampleCount) = StageSpike(SampleCount + 1)
    Next SampleCount
  End Sub
#EndIf

'--------------Store all 1 minute data to Card ----------------------------------------------
#If (StoreAllToCard = true) AND HasVM Then
  Sub StoreAllData
    Dim CorrDataLine As String * 1000
    Dim VelDataLine As String * 1000
    Dim RSSIDataLine As String * 1000
    Dim BeamCount As Long
    Dim BinCount As Long
    If InStr(1,Status.CardStatus,"Card OK.",2) = 0 Then 'if the cards not there no point in checking spikes
      CardBadCount = CardBadCount + 1
      ExitSub
    Else
      CardOkCount = CardOkCount + 1
      SpikeFileName = "CRD:VmSpikes-" & SiteID & ".csv"
      FileHandle = FileOpen (SpikeFileName,"a+b",-1)'open the spike file here
      'compose dataline and write here.
      For BeamCount = 1 To NumBeams
        Erase CorrDataLine
        Erase VelDataLine
        Erase RSSIDataLine
        CorrDataLine = CorrDataLine & "Corr: ," & BeamCount
        VelDataLine = VelDataLine & "Velocity: ," & BeamCount
        RSSIDataLine = RSSIDataLine & "RSSI: ," & BeamCount
        For BinCount = 1 To Numbins
          CorrDataLine = CorrDataLine & "," & ensCorr(BinCount,BeamCount)
          VelDataLine = VelDataLine & "," & Round(ensVelocity(BinCount,BeamCount),3)
          RSSIDataLine = RSSIDataLine & "," & ensRSSI(BinCount,BeamCount)
        Next BinCount
        FileWrite (FileHandle,RSSIDataLine & CHR(13) & CHR(10),0)
        FileWrite (FileHandle,CorrDataLine & CHR(13) & CHR(10),0)
        FileWrite (FileHandle,VelDataLine & CHR(13) & CHR(10),0)
      Next BeamCount
      FileClose(FileHandle)
    EndIf
    CardError = Status.CardStatus
  End Sub
#EndIf
'__________________________________Calculate Q Subroutine_________________________________
Sub SubCalcQ 'calculate discharge
  If CalcQ = Yes Then ' if Q calculations are wanted
    If Trans = BadDataIndicator Then 'if there is no valid transition point
      'then use standard velocity rating info for meanvel calculation
      MeanVel = VelOffset + (VelCoef * IndexVel) + (VelCoef2 * IndexVel^2) + (VelCoef3 * IndexVel^3)
    Else 'if there is a valid transition point
      If IndexVel >= Trans Then 'if iVel is greater or equal to the transition point
        'then use upper meanvel rating information
        MeanVel = UpVelOffset + (UpVelCoef * IndexVel) + (UpVelCoef2 * IndexVel^2) + (UpVelCoef3 * IndexVel^3)
      ElseIf IndexVel <= Trans Then 'if iVel is less than the transition point
        'then use lower meanvel rating information
        MeanVel = LowVelOffset + (LowVelCoef * IndexVel) + (LowVelCoef2 * IndexVel^2) + (LowVelCoef3 * IndexVel^3)
      EndIf
    EndIf
    If BadVelFlag = False AND  BadStgFlag = False Then 'Ok, now if both iVel and Stage are still good, then
      BadQFlag = False 'then Q data is still good
      'user enters rating values with keypad
      Area = StgOffset + (StgCoef*StagePrime) + (StgCoef2 * StagePrime^2)
      'check to see if iVel data is good
      Qcfs = Area * MeanVel 'calculate Q
      If Qcfs = 0 Then 'if calculated Q is exactly zero
        'then don't believe it (probably no rating data entered)
        BadQFlag = True 'Q data is now bad, so don't average it
        BadQCount = BadQCount + 1 'Q is now bad
        Qcfs = BadDataIndicator
      EndIf
    Else 'if stage or velocity were bad, then
      BadQFlag = True 'Q data is now bad, so don't average it
      BadQCount = BadQCount + 1 'and increment counter
      Qcfs = BadDataIndicator
    EndIf
  Else ' if Q calculations are not wanted (CalcQ = no)
    BadQCount = 0
    Area = NAN
    MeanVel = NAN
    Qcfs = 0
    BadQFlag = True
  EndIf
EndSub

'____________________________________Zero all Velocity Meter Arrays__________________________
#If HasVM = True Then
  Sub ZeroVMArrays
    Dim ZeroCounter As Long
    'Zero The raw data array
    Erase (Longarray())
    'Zero the bin velocity arrays
    For Bin = 1 To MaxBins
      For Beam = 1 To MaxBeams
        ensVelocity(Bin,Beam) = Nan
      Next Beam
    Next Bin
    For ZeroCounter = 1 To MaxBins
      V1(ZeroCounter) = Nan
      V2(ZeroCounter) = Nan
      VMBinVel(ZeroCounter) = Nan
    Next ZeroCounter
    IndexVel = NaN
    '  For Bin = 1 To MaxBins
    '    For Beam = 1 To MaxBeams
    '      ensCorr(Bin,Beam) = 0
    '    Next Beam
    '    AvgCorr(Bin) = 0
    '  Next Bin
    Erase (ensCorr())
    '  For Bin = 1 To MaxBins
    '    For Beam = 1 To MaxBeams
    '      ensRSSI(Bin,Beam) = 0
    '    Next Beam
    '    AvgRSSI(Bin) = 0
    '  Next Bin
    Erase (AvgRSSI())
    Erase Velspike()
    Erase RSSIspike()
    Erase Corrspike()
  EndSub
#EndIf
'----------------------------------------------------
'Read variables in from USR file (preserved variables)
Sub ReadVariables
  Public PreserveHandle As Long
  Public PreserveFileLen As Long
  Public Closeerror
  PreserveHandle = FileOpen("USR:VariableStore.txt","r",-1) 'open the preserve variable file here
  Delay (1,30,mSec)
  PreserveFileLen = FileRead(PreserveHandle,PreserveFile,500)
  Closeerror = FileClose(PreserveHandle)
  If PreserveFileLen = 0 Then
    '    'set error txt
    ExitSub
  EndIf
  Dim InVar(39) As String
  SplitStr(InVar,PreserveFile,",",39,0)
  StartBin = InVar(1)
  EndBin = InVar(2)
  StartEbbBin = InVar(3)
  EndEbbBin = InVar(4)
  StartFldBin = InVar(5)
  EndFldBin = InVar(6)
  BiRating = InVar(7)
  BiRatTran = InVar(8)
  LowRatVel = InVar(9)
  HighRatVel = InVar(10)
  SelStgPrime = InVar(11)
  SelStgSecnd = InVar(12)
  UpBeamOffset = InVar(13)
  VMPressOffset = InVar(14)
  PS1Offset = InVar(15)
  PS2Offset = InVar(16)
  SondeOffset = InVar(17)
  CalcQ = InVar(18)
  StgOffset = InVar(19)
  StgCoef = InVar(20)
  StgCoef2 = InVar(21)
  VelOffset = InVar(22)
  VelCoef = InVar(23)
  VelCoef2 = InVar(24)
  VelCoef3 = InVar(25)
  UpVelOffset = InVar(26)
  UpVelCoef = InVar(27)
  UpVelCoef2 = InVar(28)
  UpVelCoef3 = InVar(29)
  LowVelOffset = InVar(30)
  LowVelCoef = InVar(31)
  LowVelCoef2 = InVar(32)
  LowVelCoef3 = InVar(33)
  RangeSource = InVar(34)
  DucerDepthOffset = InVar(35)
  IsSubmersed = InVar(36)
  IsWQNClosed = InVar(37)
  isVMNClosed = InVar(38)
  BurstPeriod = InVar(39)
EndSub

'Store Variables to USR File (preserve variables)
'--------------------------------------------------
Sub StoreVariables
  'store variables out
  Dim Var(39) As String
  Public SendVarString As String * 500
  Public VarStringLen As Long
  Public VarHandle = Long
  Public Varbytes = Long
  Public StoreCloseErr As Long
  Dim VarCnt As Long
  Var(1) = StartBin
  Var(2) = EndBin
  Var(3) = StartEbbBin
  Var(4) = EndEbbBin
  Var(5) = StartFldBin
  Var(6) = EndFldBin
  Var(7) = BiRating
  Var(8) = BiRatTran
  Var(9) = LowRatVel
  Var(10) = HighRatVel
  Var(11) = SelStgPrime
  Var(12) = SelStgSecnd
  Var(13) = UpBeamOffset
  Var(14) = VMPressOffset
  Var(15) = PS1Offset
  Var(16) = PS2Offset
  Var(17) = SondeOffset
  Var(18) = CalcQ
  Var(19) = StgOffset
  Var(20) = StgCoef
  Var(21) = StgCoef2
  Var(22) = VelOffset
  Var(23) = VelCoef
  Var(24) = VelCoef2
  Var(25) = VelCoef3
  Var(26) = UpVelOffset
  Var(27) = UpVelCoef
  Var(28) = UpVelCoef2
  Var(29) = UpVelCoef3
  Var(30) = LowVelOffset
  Var(31) = LowVelCoef
  Var(32) = LowVelCoef2
  Var(33) = LowVelCoef3
  Var(34) = RangeSource
  Var(35) = DucerDepthOffset
  Var(36) = IsSubmersed
  Var(37) = IsWQNClosed
  Var(38) = isVMNClosed
  Var(39) = BurstPeriod
  'build send string
  SendVarString = Var(1)
  For VarCnt = 2 To 39
    SendVarString = SendVarString + "," + Var(VarCnt)
  Next VarCnt
  VarStringLen = Len(SendVarString)
  VarHandle = FileOpen("USR:VariableStore.txt","w",-1)
  Delay(1,100,mSec)
  Varbytes = FileWrite(VarHandle,SendVarString,VarStringLen + 50)
  StoreCloseErr = FileClose(VarHandle)
  StoreVariablesFlg = False
EndSub

'_______________________________________________________Calculate a Checksum for the ensemble and extract ensemble checksum ____________________________________
#If HasVM = True Then
  Sub ChecksumCheck
    'Get ensemble length (from the header)
    Dim CkSumCount As Long
    LSB = Longarray(3)
    MSB = Longarray(4)
    EnsembleLen = LSB + (MSB*256)
    'calculate checksum here to see if it matches the checksum sent by the ADCP
    CalcCheckSum = 0
    CkSumCount = 0
    For CkSumCount = 1 To EnsembleLen
      CalcCheckSum = CalcCheckSum + Longarray(CkSumCount)
    Next CkSumCount
    CalcCheckSum = 65535 AND CalcCheckSum
    EnsChecksum = Longarray(CkSumCount)
    TempL = Longarray(CkSumCount + 1)
    EnsChecksum = EnsChecksum + TempL * 256
  EndSub
#EndIf

'_____________________________________Zero Counters___________________________________________________________
Sub ZeroErrCounters
  BadBinCnt = 0
  BadEnsemble = 0
  BadEnsCount = 0
  VMRestartAttempts = 0
  BadStgCount = 0 'initialize bad stage counter
  #If WqSonde <> "NONE" Then
    WqPwrCycleCnt = 0 'set counter to zero at midnight
  #EndIf
  BadQCount = 0
  BadVelCount = 0 'initialize counter
  EventVoltFlag  = No ' reset the catastrophic event flags
  EventYSIFlag  = No
  EventQFlag  = No
  EventCDMAFlag = No
  CDMAFailure = No
  NewADCP = False
  NewPS1 = False
  NewPS2 = False
EndSub

'Function CheckVarStorage As Boolean
''this is a first try at storing variables in case of power outage
'  '----------------------
'  'SetStatus ("USRDriveSize",16384)
'  Public PreserveHandle As Long
'  Public PreserveFileLen As Long
'  Public Closeerror
'  PreserveHandle = FileOpen("USR:VariableStore.txt","r",-1) 'open the preserve variable file here
'  Delay (1,30,mSec)
'  PreserveFileLen = FileRead(PreserveHandle,PreserveFile,500)
'  Closeerror = FileClose(PreserveHandle)
'  If PreserveFileLen <> 0 Then
'    Return True
'  Else
'    Return False
'   EndIf
'
'EndFunction
'__________________________________Keypad Menus________________________________________
Sub KeypadMenu
  DisplayMenu ("Main Menu",-4)
    SubMenu ("SystemInfo")
      DisplayValue ("LastScan",LastScan)
      DisplayValue ("Program",Program)
      DisplayValue ("ProgVersDate",ProgVersDate)
      DisplayValue ("DL_Firm",OSVers)
      DisplayValue ("SerNum",SerNum)
      DisplayValue ("ProgErrors",ProgErrors)
      DisplayValue ("DataErr",DataErr)
      DisplayValue ("Low12Volts",Low12Volts)
      DisplayValue ("LithBat",LithBat)
      DisplayValue ("SkipScans",SkipScans)
      DisplayValue ("FreeCFMem",FreeCFMem)
      DisplayValue ("Restart Attemps",VMRestartAttempts)
      DisplayValue ("NeedLowMeas",LowMeas)
      DisplayValue ("NeedHighMeas",HighMeas)
    EndSubMenu
    SubMenu ("VM Data")
      DisplayValue ("LastScan",LastScan)
      DisplayValue ("StagePrime",StagePrime)
      DisplayValue ("StageSecmd",StageSecnd)
      DisplayValue ("StgDiff",StgDiff)
      DisplayValue ("UpbeamStg",UpBeamStg)
      DisplayValue ("VMPressStg",VMPressStg)
      DisplayValue ("PS1Stg",PS1Stg)
      DisplayValue ("PS2Stg",PS2Stg)
      DisplayValue ("SondeStg",SondeStg)
      DisplayValue ("IndexVel",IndexVel)
      DisplayValue ("BadQCount",BadQCount)
      DisplayValue ("Qcfs",Qcfs)
      DisplayValue ("SiteVolts",CR1Volts)
      DisplayValue ("VMvolts",VMVolts)
      DisplayValue ("ExtWHConvertVolt",ExtWHConvertVolt)
      DisplayValue ("VMpitch",VMpitch)
      DisplayValue ("VMroll",VMroll)
      DisplayValue ("VMtempC",VMtempC)
      'DisplayValue ("LastGoodBin",LastGoodBin)
      DisplayValue ("BadVelCount",BadVelCount)
      DisplayValue ("BadStgCount",BadStgCount)
      DisplayValue ("StgSelect",StgSelect)
      DisplayValue ("VMUpBeam",VMupBeam)
      DisplayValue ("VMPressure",VMpressure)
      DisplayValue ("AvgSwathRSSI",AvgSwathRSSI)
      DisplayValue ("VMMemFree",VMMemFree)
    EndSubMenu
    SubMenu ("OtherSensorData")
      DisplayValue ("LastScan",LastScan)
      #If WqSonde <> "NONE" Then
        DisplayValue ("WQBattV",WqBattV)
        DisplayValue ("WqTempC",WqTempC)
        DisplayValue ("ExoSpCond",WqSpCond)
        DisplayValue ("ExoTurbFNU",WqTurbFNU)
        DisplayValue ("WQChlugL",WqChlugL)
        DisplayValue ("WQChlRFU",WqChlRFU)
        DisplayValue ("WQDOmgL",WqDOMgl)
        DisplayValue ("WQDOSat",WqDOSat)
        DisplayValue ("WQpH",WqPH)
        DisplayValue ("WQBGAugL",WqBGAugl)
        DisplayValue ("WQBGARFU",WqBGArfu)
        DisplayValue ("WQFDomQSU",WqFDOMqsu)
        DisplayValue ("WQFdomRFU",WqFDOMrfu)
        DisplayValue ("WQNH4mgl",WqNH4mgl)
        DisplayValue ("WQNO3mgl",WqNO3mgl)
        DisplayValue ("WQCLmgl",WqCLmgl)
        DisplayValue ("WQWiperPos",WqWiperPos)
      #EndIf
    EndSubMenu
    SubMenu ("SiteParameters")
      DisplayValue ("LastScan",LastScan)
      MenuItem ("Site Id",SiteID)
      MenuItem ("SiteNumb",SiteNum)
      MenuItem ("Tech?",Tech)
      MenuItem ("VisitReason",VisitReason)
      MenuPick (Site Visit,Calib Meas,Site Down,Beam Block,WQ Fouling,Program Update,Hardware Update,Other)
      MenuItem ("RecCalibData?",RecCalibData)
      MenuPick (Yes,No)
      MenuItem ("UpBeamOffSet",UpBeamOffset)
      MenuItem ("VMPressOffset",VMPressOffset)
      MenuItem ("PS1Offset",PS1Offset)
      MenuItem ("PS2Offset",PS2Offset)
      MenuItem ("SondeOffset",SondeOffset)
      MenuItem ("SelStgPrime =",SelStgPrime)
      MenuPick (UPbeam,VMpress,PSpress,PSpress2,WqPress)
      MenuItem ("SelStgSecnd =",SelStgSecnd)
      MenuPick (UPbeam,VMpress,PSpress,PSpress2,WqPress)
      MenuItem ("TruePS1Stg",TruePS1Stg)
      MenuItem ("TruePS2Stg",TruePS2Stg)
      MenuItem ("TrueUpBeamStg",TrueUpBeamStg)
      MenuItem ("TrueVMPressStg",TrueVMPressStg)
      MenuItem ("TrueYsiStg",TrueSondeStg)
      MenuItem ("StartBin",StartBin)
      MenuItem ("EndBin",EndBin)
      MenuItem ("StartEbbBin (Pos)",StartEbbBin) 'used for ebb/flood rating
      MenuItem ("EndEbbBin (Pos)",EndEbbBin) 'used for ebb/flood rating
      MenuItem ("StartFldBin (Neg)",StartFldBin)'used for ebb/flood rating
      MenuItem ("EndFldBin (Neg)",EndFldBin) 'used for ebb/flood rating
      MenuItem ("Use Ebb/Fld Rating",BiRating) 'used for ebb/flood rating
      MenuPick (Yes,No)
      MenuItem ("Ebb-Flood Tran (vel)",BiRatTran) 'used for ebb/flood rating
      MenuItem ("MinExpVel",MinExpVel)
      MenuItem ("MaxExpVel",MaxExpVel)
      MenuItem ("MinExpStg",MinExpStg)
      MenuItem ("MaxExpStg",MaxExpStg)
      MenuItem ("Flow Sign",FlowSign)
      MenuPick (1,-1)
      MenuItem ("HighRatVel",HighRatVel)'Highest velocity covered by rating
      MenuItem ("LowRatVel",LowRatVel)'lowest velocity covered by rating
      MenuItem ("CalcQs?",CalcQ)
      MenuPick (Yes,No)
      MenuItem ("Use Y vel?",UseV2)
      MenuPick (Yes,No)
      MenuItem ("Use Pos flow angle (earth)",UseDir)
      MenuPick (Yes,No)
      MenuItem ("Positive Flow Angle",PosFlowDir)
      MenuItem ("Record All Vel Data",RecordAll)
      MenuPick (Yes,No)
      MenuItem ("Store all Variables",StoreVariablesFlg)
      MenuPick (Yes,No)
      MenuItem ("Read in Variables",GetVariablesFlg)
      MenuPick (Yes,No)
      MenuItem ("VM Power",VMPower)
      MenuPick (Yes,No)
      MenuItem ("WakeUpVM",WakeUpVM)
      MenuPick (Yes,No)
      MenuItem ("HrsCdmaOff",HrsCdmaOff)
      MenuPick (1,2,4,8,12)
      MenuItem ("CycleCdmaPwr",CycleCdmaPwr)
      MenuPick (Yes,No)
      #If (WqSonde <> "NONE") Then
        MenuItem ("CycleEXOPwr" ,WqManualCycle)
        MenuPick (Yes,No)
      #EndIf
      MenuItem ("KeepCDMAon",KeepCDMAon)
      MenuPick (Yes,No)
      MenuItem ("UseNCcdmaRelay?",IsCDMANClosed) 'New entry for normally closed relay
      MenuPick (Yes,No)
      '      MenuItem ("UseAutoLastBin",UseAutoLastBin)
      '      MenuPick (Yes,No)
      MenuItem ("SelectFilter",SelectFilter)
      MenuPick (0,1)
      MenuItem ("RSSIThreshold",RSSIThreshold)
      MenuItem ("RSSI Avg Start Bin",AvgRSSIStartBin)
      MenuItem ("RSSI Avg End Bin",AvgRSSIEndBin)
      MenuItem ("StdCorrThreshold",StdCorrThreshold)
      MenuItem ("CorrThreshold",CorrThreshold)
      #If GetNoiseFloor = Yes Then
        MenuItem ("SendPT3",SendPT3)
        MenuPick (Yes,No)
      #EndIf

    EndSubMenu
    SubMenu ("AllBinData")
      DisplayValue ("Bin1",VMBinVel(1))
      DisplayValue ("Bin2",VMBinVel(2))
      DisplayValue ("Bin3",VMBinVel(3))
      DisplayValue ("Bin4",VMBinVel(4))
      DisplayValue ("Bin5",VMBinVel(5))
      DisplayValue ("Bin6",VMBinVel(6))
      DisplayValue ("Bin7",VMBinVel(7))
      DisplayValue ("Bin8",VMBinVel(8))
      DisplayValue ("Bin9",VMBinVel(9))
      DisplayValue ("Bin10",VMBinVel(10))
      DisplayValue ("Bin11",VMBinVel(11))
      DisplayValue ("Bin12",VMBinVel(12))
      DisplayValue ("Bin13",VMBinVel(13))
      DisplayValue ("Bin14",VMBinVel(14))
      DisplayValue ("Bin15",VMBinVel(15))
      DisplayValue ("Bin16",VMBinVel(16))
      DisplayValue ("Bin17",VMBinVel(17))
      DisplayValue ("Bin18",VMBinVel(18))
      DisplayValue ("Bin19",VMBinVel(19))
      DisplayValue ("Bin20",VMBinVel(20))
      DisplayValue ("Bin21",VMBinVel(21))
      DisplayValue ("Bin22",VMBinVel(22))
      DisplayValue ("Bin23",VMBinVel(23))
      DisplayValue ("Bin24",VMBinVel(24))
      DisplayValue ("Bin25",VMBinVel(25))
      DisplayValue ("Bin26",VMBinVel(26))
      DisplayValue ("Bin27",VMBinVel(27))
    EndSubMenu
    'uncomment when you have the submenu for WQ sonde

    #If WqSonde = "WQ_SDI12" Then
      SubMenu ("RawSondeData")
        DisplayValue ("WqSDI12Sensor(1)",WqSDI12Sensor(1))
        DisplayValue ("WqSDI12Sensor(2)",WqSDI12Sensor(2))
        DisplayValue ("WqSDI12Sensor(3)",WqSDI12Sensor(3))
        DisplayValue ("WqSDI12Sensor(4)",WqSDI12Sensor(4))
        DisplayValue ("WqSDI12Sensor(5)",WqSDI12Sensor(5))
        DisplayValue ("WqSDI12Sensor(6)",WqSDI12Sensor(6))
        DisplayValue ("WqSDI12Sensor(7)",WqSDI12Sensor(7))
        DisplayValue ("WqSDI12Sensor(8)",WqSDI12Sensor(8))
        DisplayValue ("WqSDI12Sensor(9)",WqSDI12Sensor(9))
        DisplayValue ("WqSDI12Sensor(10)",WqSDI12Sensor(10))
        DisplayValue ("WqSDI12Sensor(11)",WqSDI12Sensor(11))
        DisplayValue ("WqSDI12Sensor(12)",WqSDI12Sensor(12))
        DisplayValue ("WqSDI12Sensor(13)",WqSDI12Sensor(13))
        DisplayValue ("WqSDI12Sensor(14)",WqSDI12Sensor(14))
        DisplayValue ("WqSDI12Sensor(15)",WqSDI12Sensor(15))
        DisplayValue ("WqSDI12Sensor(16)",WqSDI12Sensor(16))
        DisplayValue ("WqSDI12Sensor(17)",WqSDI12Sensor(17))
        DisplayValue ("WqSDI12Sensor(18)",WqSDI12Sensor(18))
        DisplayValue ("WqSDI12Sensor(19)",WqSDI12Sensor(19))
        DisplayValue ("WqSDI12Sensor(20)",WqSDI12Sensor(20))
        DisplayValue ("WqSDI12Sensor(21)",WqSDI12Sensor(21))
        DisplayValue ("WqSDI12Sensor(22)",WqSDI12Sensor(22))
        DisplayValue ("WqSDI12Sensor(23)",WqSDI12Sensor(23))
      EndSubMenu
    #ElseIf (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST")
      SubMenu ("RawSondeData")
        DisplayValue ("WqData(1)",WqData(1))
        DisplayValue ("WqData(2)",WqData(2))
        DisplayValue ("WqData(3)",WqData(3))
        DisplayValue ("WqData(4)",WqData(4))
        DisplayValue ("WqData(5)",WqData(5))
        DisplayValue ("WqData(6)",WqData(6))
        DisplayValue ("WqData(7)",WqData(7))
        DisplayValue ("WqData(8)",WqData(8))
        DisplayValue ("WqData(9)",WqData(9))
        DisplayValue ("WqData(10)",WqData(10))
        DisplayValue ("WqData(11)",WqData(11))
        DisplayValue ("WqData(12)",WqData(12))
        DisplayValue ("WqData(13)",WqData(13))
        DisplayValue ("WqData(14)",WqData(14))
        DisplayValue ("WqData(15)",WqData(15))
        DisplayValue ("WqData(16)",WqData(16))
        DisplayValue ("WqData(17)",WqData(17))
        DisplayValue ("WqData(18)",WqData(18))
        DisplayValue ("WqData(19)",WqData(19))
        DisplayValue ("WqData(20)",WqData(20))
        DisplayValue ("WqData(21)",WqData(21))
        DisplayValue ("WqData(22)",WqData(22))
        DisplayValue ("WqData(23)",WqData(23))
        DisplayValue ("WqData(23)",WqData(23))
        ' put exo serial stuff here
      EndSubMenu
    #EndIf

    SubMenu ("StageRating")
      MenuItem ("StgOffset",StgOffset)
      MenuItem ("StgCoef",StgCoef)
      MenuItem ("StgCoef2",StgCoef2)
    EndSubMenu
    SubMenu ("meanvel_Rating")
      MenuItem ("VelOffset",VelOffset)
      MenuItem ("VelCoef",VelCoef)
      MenuItem ("VelCoef2",VelCoef2)
      MenuItem ("VelCoef3",VelCoef3)
      MenuItem ("Trans",Trans)
      MenuItem ("UpVelOffset",UpVelOffset)
      MenuItem ("UpVelCoef",UpVelCoef)
      MenuItem ("UpVelCoef2",UpVelCoef2)
      MenuItem ("UpVelCoef3",UpVelCoef3)
      MenuItem ("LowVelOffset",LowVelOffset)
      MenuItem ("LowVelCoef",LowVelCoef)
      MenuItem ("LowVelCoef2",LowVelCoef2)
      MenuItem ("LowVelCoef3",LowVelCoef3)
    EndSubMenu
    SubMenu ("SDI12_Setup")
      MenuItem ("PSPressPort",PSPressPort)
      MenuPick (3,5)
      MenuItem ("PSPressAddr",PSPressAddr)
      MenuPick (0,1,2,3,4)
      MenuItem ("PSpress2Port?",PSpress2Port)
      MenuPick (3,5)
      MenuItem ("PSpress2Addr?",PSpress2Addr)
      MenuPick (0,1,2,3,4)
      #If WqSonde ="WQ_SDI12" Then
        MenuItem ("WQ SDI Port?",WqSDIPort)
        MenuPick (3,5)
        MenuItem ("YSI Addr?",WqAddr)
        MenuPick (0,1,2,3,4)
      #EndIf
    EndSubMenu
    #If WqSonde = "WQ_SDI12" Then
      SubMenu ("WQSondeSetup")
        MenuItem ("MilliToMicro?",MilliToMicro)
        MenuPick (Yes,No)
        MenuItem ("LocTempC",LocTempC)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocSpCond",LocSpCond)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocVolts",LocVolts)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocDOmgL",LocDOmgL)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocDOSat",LocDOSat)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocPH",LocPH)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocORP",LocORP)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocDepth",LocDepth)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocTurbFNU",LocTurbFNU)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocFdomRFU",LocFdomRFU)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocFdomQSU",LocFdomQSU)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocChlorMGL",LocChlorMGL)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocChlorRFU",LocChlorRFU)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocBGA",LocBGA)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocAmmonium",LocAmmonium)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocNitrate",LocNitrate)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
        MenuItem ("LocChloride",LocChloride)
        MenuPick (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)
      EndSubMenu
    #EndIf
  EndMenu
EndSub

'_______________________________________Main Program____________________________________
'Main Program
'All the subroutines will remain in the program but they will not be called in the scan unless they are directly used in the WQ burst test
BeginProg
  'INITIALIZE variables here that will hold their value from scan to scan
  'Timer(1,mSec,2)
  MissedEns = 0
  ScanDiff = 0
  'Set comms mode to Zero and include in open commands if using c1,c3 on cr6
  UseCommsZeroForADCP = False
  UseCommsOneForSonde = False 'if Max232 is present this flag should show true in the public table
  UseCommsZeroForSonde = False 'If no Max232 is present this flag should show true in the public table
  WqUseCPort = False 'If using C1/C3 this flag should be true. Future versions may have option to use U ports instead.
      If (WqSerialPort = ComC1) OR (WqSerialPort = ComC3) Then
      WQUseCPort = True 'Variable to indicate if WQ is in the C port
      EndIf
      If (IsWqMax232 = True) AND (WqUseCPort = True) Then ' if sonde is using Max232 and is in a C port
        UseCommsOneForSonde = True 'then me need to use comms mode one to speak TTL
        EndIf
      If (IsWqMax232 = False) AND (WqUseCPort = True) Then 'ifsonde isn't using a Max232 and is in a c port
        UseCommsZeroForSonde = True 'then we need to uses comms mode zero to speak standard RS232
        EndIf
  PanelTemp(PTempC,250)
  PTempF = PTempC * 9/5 + 32
  Call GetStartup 'setup all the statup\default info
  Call CalcLoopInterval 'calculate the loop interval from the ScanRate and ScanUnit
  Call Initialize 'initialize important variables
  

  '---------------------------------------------------------------------
  ' This must be done inside scan
  '  If GetVariablesFlg = True Then
  '    Call ReadVariables
  '    GetVariablesFlg = False
  '  EndIf
  '--Start Scan ----------------------------------------------------------------------
  'The Scan starts here and we initialize variables that are changed during every scan
  '-----------------------------------------------------------------------------------
  Scan (ScanRate,ScanUnit,5,0)'set to scan every 60 seconds
    Timer(5,mSec,2)
    RealTime DebugTime()
    CallTable DebugTimer
    'Dim InCount As Long
    ScanStart = Timer(2,mSec,2)
    ScanStart = ScanStart/1000
    '------------------------------------------------------------------------------------------------------------------------
    If GetVariablesFlg = True Then
      Call ReadVariables
      GetVariablesFlg = False
    EndIf
    If (SendCMD) Then Call SendSetup
    'If we have an EXO turn it on here
    #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
      #If LoggerType = CR1000 Then 'turn on the Sonde
        If IsWQNClosed Then
          PortSet(WqSwitchPort,0)
        Else
          PortSet(WqSwitchPort,1)
        EndIf
      #ElseIf LoggerType = CR6 Then
        If UseSW12_2_forWQ Then 'use the SW12 port no 2
          SW12(2,1)
        Else
          If IsWQNClosed Then
            PortSet(WqSwitchPort,0)
          Else
            PortSet(WqSwitchPort,1)
          EndIf
        EndIf
      #EndIf
      #If WqSonde = "WQ_SERIAL_BURST" Then
        iCount=1
        Erase BurstIn
        Erase BurstArray()
        Erase BurstData()
      #EndIf
      'Redeploy = False
      'Call SetBaud
    #EndIf
    RealTime (rTime)' get current time from datalogger real time clock
    RealSeconds = (Hour * 3600) + (Minute * 60) + Second
    'see if time is close to 15 minute or Day Interval
    Mod5Minutes = RealSeconds MOD 300
    Mod15Minutes = RealSeconds MOD 900
    Mod60Minutes = RealSeconds MOD 3600
    ModDay = RealSeconds MOD 86400
    '    If Mod15Minutes < 85 Then 'If within 85 seconds of 15 minute time-period
    '      'Reset all 15 minute flags or zero variables here
    '      'RunEnsSpikes = 0
    '      'SpikeCounter = 0
    '    EndIf
    If (ModDay > 300) AND (ModDay < 420) Then 'Reset bad data counter at between 5 and 7 minutes after Midnight
      'Reset all Daily flags or zero variables here
      Call ZeroErrCounters 'Reset Counters at midnight
    Call GetLastScan
    Call GetSysInfo
    Call ExtPwrSource
      #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
        SetEXOTimeFlg = True
      #EndIf
      StoreVariablesFlg = True
    Else
      Rec24HrFlag = No  'otherwise keep it turned off
      'SetVMTimeFlg = No
    EndIf
    #If WqSonde = "WQ_SERIAL_BURST" Then
      BurstTimeReached = Timer(5,mSec,4)
      BurstReachedMod = Mod15Minutes
      'On initial compile the burstperiod is set to zero. Have it switch to the standard 1150 unless user declares otherwise.
      If BurstPeriod = 0 Then
      BurstPeriod = 250
      ElseIf BurstPeriod < 250 Then 'if user enters values less than 250, but not 0, bring it up to 250. This is the max rate that the sonde can collect.
        BurstPeriod = 250
      EndIf
      If Mod15Minutes > 830 AND Mod15Minutes < 860 Then 'if time is within 20sec of the 14th minute of the scan
        GetBurst = True 'set the burst flag to true
      Else
        GetBurst = False 'outside the 15sec of the 14th minute, don't burst
      EndIf
    #EndIf
    If Mod15Minutes < 15 Then 'when time to output data...within 14 seconds of 15 minute period
      If RecordAll = Yes Then RecAllVelFlag = Yes
      #If WqSonde <> "NONE" Then
        If WqDead = True Then RecAQFlag = True
      #EndIf
      RecAQFlag = False
    EndIf
    'Now check the next scan to see if we missed it
    If (Mod15Minutes < 35) AND (RecDataFlag = No) Then 'Check next scan (15 min within 34 Seconds)
      Rec15minFlag = Yes 'always set record data flag to yes every fifteen minutes
      #If WqSonde <> "NONE" Then
        If WqDead = True Then RecAQFlag = Yes
      #EndIf
      If RecordAll = Yes Then RecAllVelFlag = Yes
      RecDataFlag = No 'Set it back to false for next time
    EndIf
    #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
      If (Mod15Minutes > 770) AND (Mod15Minutes < 790) Then 'wipe 13mins +- 10s into a 15 min period when not collecting burst, set a disable variable
        Wipeflag = True
      Else
        Wipeflag = false
      EndIf
    #EndIf
    BeforeBurst = Timer(2,msec,4)
    BeforeBurst = BeforeBurst/1000
    #If WqSonde = "WQ_SDI12" Then
      Call GetWq_SDI12 'get YSI data
    #ElseIf (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
      If WqParamOrder(1) = BadDataIndicator OR NoSondeTrig <> 0 Then Redeploy = True
      If Redeploy = True Then 'EXO not setup yet
        Call ParamCheck
        Delay (1,1,Sec)
        Call DefineParamsOrder
        Delay (1,1,Sec)
        Call DefineLocs
        Delay (1,1,Sec)
        Call SetDelim
        Delay (1,1,Sec)
        Redeploy = False
      Else 'if not redeploy Get single data point
        Call GetWQ_Serial 'get a single data point
        Delay (1,30,mSec)
        Call ParseData
      EndIf '
      Delay (1,50,mSec)
      If GetBurst AND NOT Redeploy Then 'ok we need a burst
        #If WqSonde = "WQ_SERIAL_BURST" Then
          'If WqError = False  Then 'If sonde is having probs then don't burst <--- Commented this because I think we still want to try to set the Run function even
          ' if it didn't respond to the previous "data" attempt
            Call setburst 'set the period to output the data from the sonde
            Call GetBurstArray 'set up the array to store the burst values
            BurstDebugCount = BurstDebugCount+1 'we made it this far, count up
            '              BurstMedDate = ""
            '              BurstMedTime = ""
            BurstCount = 0 'reset our burst counter
            TotalBurstVals = 0 'reset variable that will store how many values used to calculate burst table
            BurstErrCnt = 0 'reset error counter
            GotToBurst = GotToBurst + 1 'we got to the burst (duplicate variable as the BurstDebugCount)
            jCount = 0 'reset j Loop counter
            kCount = 0 'reset k Loop counter
            For jCount = 1 To MaxBurstCnt 'de-construct BurstArray and send to table.  too slow to do in get loop
              For kCount = 1 To 23 'this is the loop to pull the parameters
                BurstData(kCount) = BurstArray(jCount,kCount)' get one burst string
              Next kCount 'pull all 23 parameters within the n-th part of the j-loop and store in the array
              Call parseburst 'parse array into proper fields
              If WqError Then 'if we didn't get data
                WqBadData = true 'set a flag
              Else
                WqBadData = false 'otherwise, we are good
              EndIf
              '                StdDevSpa(StdTurbFNU,MaxBurstCnt,BurstArray(1,WqLocTurb))
              '                Delay(1,30,msec)
              BurstCount = BurstCount+1 'burst count increase
              If WqError Then 'an error occured while trying to read a burst value (in "ParseBurst" sub)
                BurstErrCnt = BurstErrCnt + 1 'count up if the error occurs
              EndIf
              If BurstErrCnt > BurstMaxErrCnt Then 'if we have more errors than the threshold
                TotalBurstVals = jCount - BurstErrCnt 'the total number of values used for the burst should be jCount - number of errors
                SerialOut (WqSerialPort,"0" + CHR(13) + CHR(10),"#",3,50) 'send a "0" out to stop the SOA from attempting to burst
                ExitFor 'if error occurs more than a threshold, exit the loop
              EndIf

             If BurstCount >= MaxBurstCnt Then 'if our burst count has reached our threshold
               TotalBurstVals = jCount - BurstErrCnt 'if there's an interuption during the burst but it comes back online, we need to subtract how many times error happened to calculate a total number of values
               BurstMissed = False 'we had good values coming in, so Make sure disable variable is set to false so the values get processed
               RecBurstFlag = True 'set our output flag to true
               CallTable SecBurst 'call the table that stores individual 1sec values
               CallTable Burst 'call the burst table
             ElseIf BurstCount < MaxBurstCnt AND WqError = True Then
               BurstMissed = False 'we have good values
               RecBurstFlag = False 'don't set the output flag because we haven't reached our threshold
               CallTable SecBurst 'store the next 1sec value
             ElseIf BurstCount < MaxBurstCnt AND WqError = False Then
               BurstMissed = False
               RecBurstFlag = False
               CallTable SecBurst
               CallTable Burst 'Need to call table to store the values in the table memory until the output flag (RecBurstFlag) is true
             EndIf
              Delay(1,1,msec)
            Next jCount 'restart the loop until we reach max burst count
          If BurstCount < MaxBurstCnt Then 'didn't reach our burst threshold, so let's Call and output SecBurst and Burst Tables
            BurstMissed = True 'Disable processing of Median values in burst table
            RecBurstFlag = True 'set the output flag to true
            CallTable SecBurst 'store the final value in the SecBurst table
            CallTable Burst 'Call the burst table to output median values no with however many 1sec values were collected
            EndIf

          If TotalBurstVals >= MinBurstVals Then 'if we reached our minimum threshold for 1sec values
          Call CopyMedBurstVals 'copy the values from the burst table to the "Med..." values to be sampled into the AQ table
          Else
          Call ResetBurstVars 'we didn't reach our minimum threshold, NAN all values to be sampled into AQ table
          EndIf
          SerialFlush (WqSerialPort) 'flush the port to ensure nothing gets inadvertantly populated
        BurstCount = 0 'reset our burst count back to 0
      #EndIf 'burst
    EndIf 'getburst and not redeploy
    '      EndIf 'Redeploy = true

    If (WqParamOrder(1) = BadDataIndicator) OR (WqError = True) Then'unable to initialize or bad data
      #If DWRSonde = False Then
      Call WQ_Mark_Bad
      Erase WqData()
      #EndIf
      If WqDead AND WqPwrCycleCnt >= WQDeadCntMax Then 'cycle power to the Sonde
        Call CycleWQPower
      EndIf
      WqErrCount = WqErrCount + 1
      WqPwrCycleCnt = WqPwrCycleCnt + 1
      If WqErrCount >= WQDeadCntMax Then
        WqDead = True
        'WqDeadCnt = WqDeadCnt + 1
      EndIf
    EndIf 'error
  #EndIf
  AfterBurst = Timer(2,msec,4)
  AfterBurst = AfterBurst/1000
    #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then
      If WqError = true Then
        WqBadData = True
      Else
        WqBadData = False
      EndIf
    #ElseIf WqSonde = "WQ_SDI12" Then
      If WqError = true Then
        WqBadData = True
      Else
        WqBadData = False
      EndIf
    #EndIf
  #If (WqSonde = "WQ_SERIAL") OR (WqSonde = "WQ_SERIAL_BURST") Then ' Check WQ flags and do things!!
    If Wipeflag = true Then
      Call WipeWQ
      Delay (1,1,Sec)
      WipeTime = Status.TimeStamp(0,1)
    EndIf
    If SetEXOTimeFlg = True Then
      Call SetEXOTime
    EndIf
    If WqManualCycle = true Then
      Call CycleWQpower
    EndIf
  #EndIf
  'Call All Data Tables (time them to make sure nothing is being hung up.
  DataTabsStart = Timer(2,msec,4)
  DataTabsStart = DataTabsStart/1000
  CallTable DataOut
  DataOutCount = DataOutCount + 1
  DataOutEnd = Timer (2,msec,4)
  DataOutEnd = DataOutEnd/1000
  DataOutTotTime = DataOutEnd - DataOutStart
  Data1mStart = Timer (2,msec,4)
  Data1mStart = Data1mStart/1000
  CallTable Data1m
  Data1mCount = Data1mCount + 1
  Data1mEnd = Timer(2,msec,4)
  Data1mEnd = Data1mEnd/1000
  Data1mTotTime = Data1mEnd - Data1mStart
  AQTabStart = Timer(2,msec,4)
  AQTabStart = AQTabStart/1000
  AvgIndexVel = DataOut.IndexVel_Avg
  AvgVMTemp = DataOut.VMtempC_Avg
  AvgVMPitch = DataOut.VMpitch_Avg
  AvgVMRoll = DataOut.VMroll_Avg
  AvgPS1Stg = DataOut.PS1Stg_Avg
  AvgPS2Stg = DataOut.PS2Stg_Avg
  AvgUpBeamStg = DataOut.UpBeamStg_Avg
  '      AvgLoggerQcfs = DataOut.Qcfs_Avg
  '      AvgStagePrime = Dataout.StagePrime_Avg
  '      AvgStageSec = Dataout.StageSecnd_Avg
  Delay (1,3,mSec)
  CallTable Aquarius
  #If WqSonde = "WQ_SERIAL_BURST" Then
  If Rec15minFlag = True Then
    Call ResetBurstVars
  EndIf
  #EndIf
  AQcount = AQcount + 1
  AQTabEnd = Timer (2,msec,4)
  AQTabEnd = AQTabEnd/1000
  AQTabTotTime = AQTabEnd - AQTabStart   'store the instantaneous variables to the aquarius table
  Rec15minFlag = false 'turn off data table trigger flags (until they get triggered in the program above at the next appropriate interval)
        #If WqSonde = "WQ_SERIAL_BURST" Then
  RecBurstFlag = False
  '        Call ClearBurstVars
       #EndIf
  RecAQFlag = False
  If StoreVariablesFlg = true Then Call StoreVariables
  ScanEnd = Timer(2,mSec,4)
  ScanEnd = ScanEnd/1000
  ProcessTime = ScanEnd - ScanStart
  CallTable Debugger
  CallTable SVMaq
NextScan
EndProg
